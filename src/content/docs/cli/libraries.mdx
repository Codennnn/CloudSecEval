# 库（Library）

许多应用程序都需要解决相似的通用问题，或在不同场景下复用模块化组件。Nest 提供了多种方式来应对这些需求，每种方式都在不同层面上解决问题，以实现不同的架构和组织目标。

Nest 的[模块](/modules)非常适合在单个应用内部提供执行上下文 (Execution Context) 来共享组件。模块也可以打包成 [npm](https://npmjs.com) 包，以创建可在不同项目中安装和复用的库。这种方式非常适合分发可配置、可复用的库，供不同、松散关联甚至无关联的组织使用（例如分发/安装第三方库）。

对于在组织内部（例如公司或团队）共享代码，采用更轻量的方式通常更高效。Monorepo 正是为此而设计。在 Monorepo 中，**库**为代码共享提供了一种简单、轻量的方式。在 Nest Monorepo 结构下，你可以用库轻松地将共享组件组装成应用。实际上，这种方式鼓励你将应用拆分为多个模块化组件，并推动开发流程转向构建和组合这些组件。

## Nest 库

Nest 库是一种特殊的 Nest 项目类型，它与应用不同，无法独立运行。你必须将库导入到某个应用中，其代码才能被执行。本节介绍的库内置支持仅适用于 Monorepo 模式（标准模式项目可通过 npm 包实现类似功能）。

例如，某个组织可能会开发一个 `AuthModule`，用于实现公司内统一的身份验证策略，并管理所有内部应用的认证。与其为每个应用单独构建该模块，或将其打包为 npm 包再逐个安装，不如在 Monorepo 中将该模块定义为一个库。采用这种方式，所有使用该库的应用都能实时获取 `AuthModule` 的最新版本。这种方式不仅有利于协作开发和组装组件，也能显著简化端到端测试。

## 创建库

任何适合复用的功能都可以被组织成一个库。决定哪些功能应作为库，哪些应属于应用，是一个架构设计决策。创建库并非简单地将现有应用代码复制到新库中。当功能被组织成库时，其代码必须与应用解耦。这通常需要你在前期投入**更多**时间，并促使你做出一些在紧耦合代码中无需考虑的设计决策。但这些额外的努力是值得的，因为它能让库在多个应用之间被更快速地组装和复用。

要开始创建库，运行以下命令：

```bash
$ nest g library my-library
```

运行该命令时，`library` Schematics (原型生成器) 会提示你为库输入一个前缀（也称为“别名”）：

```bash
What prefix would you like to use for the library (default: @app)?
```

这会在你的工作空间中创建一个名为 `my-library` 的新项目。库项目（library-type project）与应用项目（application-type project）一样，都是通过 Schematics 生成到一个带名称的文件夹中。所有库都统一存放在 Monorepo 根目录下的 `libs` 文件夹中。Nest 会在创建第一个库时自动创建 `libs` 文件夹。

为库生成的文件与为应用生成的文件略有不同。以下是执行上述命令后 `libs` 文件夹的内容：

<FileTree
  data={[
    {
      name: 'libs',
      children: [
        {
          name: 'my-library',
          children: [
            {
              name: 'src',
              children: [
                { name: 'index.ts' },
                { name: 'my-library.module.ts' },
                { name: 'my-library.service.ts' },
              ],
            },
            { name: 'tsconfig.lib.json' },
          ],
        },
      ],
    },
  ]}
/>

`nest-cli.json` 文件会在 `projects` 键下为该库新增一项：

```json
...
{
    "my-library": {
      "type": "library",
      "root": "libs/my-library",
      "entryFile": "index",
      "sourceRoot": "libs/my-library/src",
      "compilerOptions": {
        "tsConfigPath": "libs/my-library/tsconfig.lib.json"
      }
}
...
```

`nest-cli.json` 中库与应用的元数据有两个区别：

- `"type"` 属性被设置为 `"library"`，而不是 `"application"`。
- `"entryFile"` 属性被设置为 `"index"`，而不是 `"main"`。

这些差异使构建过程能够正确处理库。例如，库通过 `index.js` 文件导出其功能。

与应用项目一样，每个库都有自己的 `tsconfig.lib.json` 文件，它继承自 Monorepo 根目录下的 `tsconfig.json` 文件。你可以根据需要修改该文件，为库提供特定的 TypeScript 编译选项。

你可以通过 CLI 命令构建该库：

```bash
$ nest build my-library
```

## 使用库

当配置文件就位后，使用库就变得非常简单。那么，如何在 `my-project` 应用中从 `my-library` 库导入 `MyLibraryService` 呢？

首先要注意，使用库模块和使用其他任何 Nest 模块的方式完全相同。Monorepo 的作用是透明地管理路径，从而简化了库的导入和构建过程。要使用 `MyLibraryService`，你需要导入其所属的模块 `MyLibraryModule`。如下所示，修改 `my-project/src/app.module.ts` 文件：

```ts
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { MyLibraryModule } from '@app/my-library'

@Module({
  imports: [MyLibraryModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

请注意，上面的 `import` 语句中使用了路径别名 `@app`，这正是我们之前通过 `nest g library` 命令为库指定的前缀 (`prefix`)。其底层原理是，Nest 利用了 TypeScript 的路径映射 (path mapping) 功能。当你添加一个库时，Nest 会自动更新 Monorepo 全局 `tsconfig.json` 文件中的 `paths` 属性，如下所示：

```json
"paths": {
    "@app/my-library": [
        "libs/my-library/src"
    ],
    "@app/my-library/*": [
        "libs/my-library/src/*"
    ]
}
```

简而言之，Monorepo 与库功能的结合，使得在应用中引入库模块的过程变得简单而直观。

同样的机制也适用于构建和部署由多个库构成的应用。一旦导入了 `MyLibraryModule`，当你运行 `nest build` 时，构建过程会自动处理所有模块解析，并将应用及其所有库依赖一同打包以便部署。Monorepo 的默认编译器是 **webpack**，因此最终的产物会将所有转译后的 JavaScript 文件打包成一个单独的文件。当然，你也可以按照[此处](/cli/monorepo#global-compiler-options)的说明切换到 `tsc` 编译器。

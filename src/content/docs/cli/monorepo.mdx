# 工作空间

Nest 提供了两种代码组织模式：

- **标准模式**：适用于构建单个独立的应用程序。这类项目有自己独立的依赖和配置，不涉及模块共享或复杂的构建优化，是默认的模式。
- **Monorepo 模式**：此模式将多个代码项目组织在一个轻量级的 Monorepo 中，尤其适合大型开发团队和多项目环境。它能自动化部分构建流程，让你轻松创建和组合模块化组件、促进代码复用、简化集成测试，并方便地共享 `eslint` 规则等项目级配置。相比 Git 子模块等方案，它更易于使用。Monorepo 模式引入了**工作空间（Workspace）** 的概念，通过 `nest-cli.json` 文件来协调其中各个项目的关系。

值得注意的是，几乎所有 Nest 功能都与代码组织模式无关，**唯一**的区别在于项目的组合方式以及构建产物的生成方式。无论是命令行工具（CLI）、核心模块还是附加模块，在两种模式下都能正常工作。

此外，你可以随时从标准模式切换到 Monorepo 模式，因此可以等到明确需要该模式的优势时再做转换。

## 标准模式

当你运行 `nest new` 命令时，Nest CLI 会使用其内置的 Schematic (原型生成器) 为你创建一个新的项目。具体操作如下：

1.  创建一个新文件夹，其名称对应你在 `nest new` 命令中提供的 `name` 参数。
2.  在该文件夹中生成一套默认文件，构成一个最小化的基础 Nest 应用。你可以在 [typescript-starter](https://github.com/nestjs/typescript-starter) 仓库中查看这些文件。
3.  额外生成 `nest-cli.json`、`package.json` 和 `tsconfig.json` 等文件，用于配置和启用编译、测试及服务等工具。

从这里开始，你可以修改起始文件、添加新组件、安装依赖（如 `npm install`），并按照文档的其他部分继续开发你的应用。

## Monorepo 模式

要启用 Monorepo 模式，你需要从一个标准模式的项目开始，然后向其添加另一个项目。项目可以是完整的**应用（Application）**（通过 `nest generate app` 添加），也可以是可复用的库（通过 `nest generate library` 添加）。我们将在下文详细介绍这两类项目。这里的关键在于：**向标准模式的项目中添加一个新项目，就会将其自动转换为 Monorepo 模式**。下面来看一个例子。

如果我们运行：

```bash
$ nest new my-project
```

我们就创建了一个标准模式的项目，其文件夹结构如下：

<FileTree
  data={[
    { name: 'node_modules', type: 'folder' },
    {
      name: 'src',
      children: [
        { name: 'app.controller.ts' },
        { name: 'app.module.ts' },
        { name: 'app.service.ts' },
        { name: 'main.ts' },
      ],
    },
    { name: 'nest-cli.json' },
    { name: 'package.json' },
    { name: 'tsconfig.json' },
    { name: 'eslint.config.mjs' },
  ]}
/>

我们可以通过以下方式将其转换为 Monorepo 模式：

```bash
$ cd my-project
$ nest generate app my-app
```

此时，`nest` 会将现有结构转换为 Monorepo 模式。这一转换会带来几个重要变化，最终的文件夹结构如下：

<FileTree
  data={[
    {
      name: 'apps',
      children: [
        {
          name: 'my-app',
          children: [
            {
              name: 'src',
              children: [
                { name: 'app.controller.ts' },
                { name: 'app.module.ts' },
                { name: 'app.service.ts' },
                { name: 'main.ts' },
              ],
            },
            { name: 'tsconfig.app.json' },
          ],
        },
        {
          name: 'my-project',
          children: [
            {
              name: 'src',
              children: [
                { name: 'app.controller.ts' },
                { name: 'app.module.ts' },
                { name: 'app.service.ts' },
                { name: 'main.ts' },
              ],
            },
            { name: 'tsconfig.app.json' },
          ],
        },
      ],
    },
    { name: 'nest-cli.json' },
    { name: 'package.json' },
    { name: 'tsconfig.json' },
    { name: 'eslint.config.mjs' },
  ]}
/>

这个 `generate app` Schematic 重构了项目结构：它将每个应用都移动到 `apps` 文件夹下，并为每个应用根目录创建一个专属的 `tsconfig.app.json` 文件。我们最初的 `my-project` 应用，现在与新添加的 `my-app` 一样，都位于 `apps` 文件夹下，并成为了这个 Monorepo 的**默认项目**。我们稍后会详细解释默认项目的概念。

<CalloutInfo type="warning">
  请注意，只有遵循标准 Nest 项目结构的项目，才能顺利地从标准模式转换为 Monorepo
  模式。具体而言，转换工具会尝试将原有的 `src` 和 `test` 文件夹移动到根目录下的 `apps`
  文件夹中。如果你的项目不符合此结构，转换过程可能会失败或产生意外结果。
</CalloutInfo>

## 工作空间项目

在 Monorepo 模式中，我们使用工作空间来管理其内部的多个项目。一个项目可以是：

- **应用（Application）**：一个完整的 Nest 应用，包含用于启动应用的 `main.ts` 文件。在功能上，工作空间中的应用与标准模式下的应用完全相同，区别仅在于编译和构建过程。
- **库（Library）**：一种用于封装通用功能（如模块、提供者、控制器等）并在其他项目中复用的软件包。库本身无法独立运行，也没有 `main.ts` 文件。关于库的更多信息，请参考[库（Libraries）章节](/cli/libraries)。

所有工作空间都有一个默认项目（必须是应用类型）。它由顶层 `nest-cli.json` 文件中的 `"root"` 属性指定，该属性指向默认项目的根目录（更多细节见下文的 [CLI 属性](#cli-属性) 部分）。通常，默认项目就是你一开始创建的标准模式应用，它在转换到 Monorepo 模式时被自动设置。当你遵循标准步骤操作时，Nest CLI 会自动配置好这个属性。

默认项目供 `nest` 命令（如 `nest build` 和 `nest start`）在未指定项目名称时使用。

例如，在上述多包仓库结构中，运行：

```bash
$ nest start
```

会启动 `my-project` 应用。若要启动 `my-app`，则需使用：

```bash
$ nest start my-app
```

## 应用

应用（Application）项目（通常简称为"应用"）是可以独立运行和部署的完整 Nest 应用。你可以通过 `nest generate app` 命令生成一个应用项目。

该命令会自动生成项目骨架，包含 [typescript starter](https://github.com/nestjs/typescript-starter) 中的标准 `src` 和 `test` 文件夹。与标准模式不同，Monorepo 下的应用项目不会包含任何包依赖文件（`package.json`）或其他项目配置文件（如 `.prettierrc` 和 `eslint.config.mjs`）。相反，依赖和配置文件在整个 Monorepo 中统一管理。

不过，Schematic 会在项目根目录下生成一个项目专用的 `tsconfig.app.json` 文件。该配置文件会自动设置合适的构建选项，包括正确设置编译输出目录。该文件继承自 Monorepo 根目录的 `tsconfig.json` 文件，因此你可以在全局管理大部分配置，同时在项目级别进行个别覆盖。

## 库

如前所述，库（Library）项目（通常简称为“库”）是 Nest 的可复用组件包，它本身不能独立运行，需要被集成到某个应用中。你可以通过 `nest generate library` 命令生成一个库项目。至于哪些功能适合放入库中，这是一个架构设计决策。我们将在[库（Libraries）](/cli/libraries)章节中详细讨论此话题。

## CLI 属性

Nest 将组织、构建和部署标准项目及 Monorepo 的元数据保存在 `nest-cli.json` 文件中。Nest 会在你添加项目时自动补充和更新该文件，因此你通常无需手动编辑它。不过，有些设置你可能需要手动调整，因此了解其文件结构会很有帮助。

在按照上述步骤创建 Monorepo 后，我们的 `nest-cli.json` 文件如下所示：

```json
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "apps/my-project/src",
  "monorepo": true,
  "root": "apps/my-project",
  "compilerOptions": {
    "webpack": true,
    "tsConfigPath": "apps/my-project/tsconfig.app.json"
  },
  "projects": {
    "my-project": {
      "type": "application",
      "root": "apps/my-project",
      "entryFile": "main",
      "sourceRoot": "apps/my-project/src",
      "compilerOptions": {
        "tsConfigPath": "apps/my-project/tsconfig.app.json"
      }
    },
    "my-app": {
      "type": "application",
      "root": "apps/my-app",
      "entryFile": "main",
      "sourceRoot": "apps/my-app/src",
      "compilerOptions": {
        "tsConfigPath": "apps/my-app/tsconfig.app.json"
      }
    }
  }
}
```

该文件分为以下几个部分：

- 全局部分，包含用于控制标准项目和 Monorepo 的顶层属性。
- 顶层属性 `"projects"`，包含每个项目的元数据。该部分仅在 Monorepo 中存在。

顶层属性说明如下：

- `"collection"`：指定用于生成组件的 Schematic 集合，通常无需更改。
- `"sourceRoot"`：在标准模式下，指定单一项目的源代码根目录；在 Monorepo 模式下，指定默认项目的源代码根目录。
- `"compilerOptions"`：一个对象，键是编译器选项名，值是对应的设置。详见下文。
- `"generateOptions"`：一个对象，键是全局生成选项名，值是对应的设置。详见下文。
- `"monorepo"`：（仅 Monorepo）在 Monorepo 模式下，此值始终为 `true`。
- `"root"`：（仅 Monorepo）指向默认项目的项目根目录。

## 全局编译器选项

这些属性用于指定要使用的编译器，以及影响**任何**编译步骤的各种选项，无论是通过 `nest build` 还是 `nest start`，也无论使用的是 `tsc` 还是 webpack。

| 属性名              | 属性值类型    | 说明                                                                                                                                                                                                                                          |
| ------------------- | ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `webpack`           | boolean       | 若为 `true`，使用 [webpack 编译器](https://webpack.js.org/)。若为 `false` 或未设置，则使用 `tsc`。在 Monorepo 模式下，默认值为 `true`（使用 webpack），在标准模式下，默认值为 `false`（使用 `tsc`）。详情见下文。（已弃用：请改用 `builder`） |
| `tsConfigPath`      | string        | （**仅限 Monorepo**）指向包含 `tsconfig.json` 设置的文件，当在未指定 `project` 选项的情况下调用 `nest build` 或 `nest start` 时（例如，构建或启动默认项目时）会使用该文件。                                                                   |
| `webpackConfigPath` | string        | 指定 webpack 配置文件路径。如果未指定，Nest 会查找 `webpack.config.js` 文件。详情见下文。                                                                                                                                                     |
| `deleteOutDir`      | boolean       | 若为 `true`，每当编译器被调用时，会首先移除编译输出目录（在 `tsconfig.json` 中配置，默认是 `./dist`）。                                                                                                                                       |
| `assets`            | array         | 启用后，每当编译步骤开始时会自动分发非 TypeScript 资产（在 `--watch` 增量编译模式下不会分发资源）。详情见下文。                                                                                                                               |
| `watchAssets`       | boolean       | 若为 `true`，以 watch 模式运行，监视**所有**非 TypeScript 资产。（如需更细粒度的资产监控，请参见下方[资源（Assets）](#资源文件)部分。）                                                                                                       |
| `manualRestart`     | boolean       | 若为 `true`，启用 `rs` 快捷命令以手动重启服务器。默认值为 `false`。                                                                                                                                                                           |
| `builder`           | string/object | 指定 CLI 使用哪种 `builder` 编译项目（`tsc`、`swc` 或 `webpack`）。如需自定义 builder 行为，可传递一个包含 `type`（`tsc`、`swc` 或 `webpack`）和 `options` 两个属性的对象。                                                                   |
| `typeCheck`         | boolean       | 若为 `true`，则为 SWC 驱动的项目启用类型检查（当 `builder` 为 `swc` 时）。默认值为 `false`。                                                                                                                                                  |

## 全局生成选项

这些属性用于指定 `nest generate` 命令的默认生成选项。

| 属性名 | 属性值类型        | 说明                                                                                                                                                                                                                        |
| ------ | ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `spec` | boolean 或 object | 若为布尔值，`true` 表示默认启用 spec 文件生成，`false` 表示禁用。命令行参数或项目级 `generateOptions` 设置会覆盖该值（见下文）。若为对象，每个 key 代表一个 Schematic 名称，布尔值决定该 Schematic 是否默认生成 spec 文件。 |
| `flat` | boolean           | 如果为 true，所有生成命令将生成扁平结构。                                                                                                                                                                                   |

以下示例使用布尔值指定所有项目默认禁用 spec 文件生成：

```json
{
  "generateOptions": {
    "spec": false
  },
  ...
}
```

以下示例使用布尔值指定所有项目默认生成扁平结构：

```json
{
  "generateOptions": {
    "flat": true
  },
  ...
}
```

在下例中，仅为 `service` 原型生成器（如 `nest generate service...`）禁用 spec 文件生成：

```json
{
  "generateOptions": {
    "spec": {
      "service": false
    }
  },
  ...
}
```

<CalloutInfo type="warning">
  <div>
    当 `spec` 以对象形式指定时，Schematic 的 key 目前不支持自动别名处理。这意味着如果只指定了 `service: false`，但通过别名 `s` 生成 service，仍会生成 spec 文件。为确保命令名和别名都按预期工作，请同时指定命令名和别名，如下所示：
  </div>

```json
{
  "generateOptions": {
    "spec": {
      "service": false,
      "s": false
    }
  },
  ...
}
```

</CalloutInfo>

## 项目专属 generate 选项

除了设置全局 generate 选项，你还可以为每个项目单独配置。项目专属的 generate 选项格式与全局选项完全一致，但直接写在项目配置下。

项目专属 generate 选项会覆盖全局 generate 选项。

```json
{
  "projects": {
    "cats-project": {
      "generateOptions": {
        "spec": {
          "service": false
        }
      },
      ...
    }
  },
  ...
}
```

<CalloutInfo type="warning">
  generate 选项的优先级顺序为：**CLI 命令行参数 > 项目级选项 >
  全局选项**。也就是说，命令行中指定的选项会覆盖项目级选项，而项目级选项会覆盖全局选项。
</CalloutInfo>

## 指定编译器

默认编译器之所以不同，是因为对于大型项目（在 Monorepo 中更常见），webpack 在构建速度和将所有组件打包成单一文件方面具有显著优势。如果你希望每个文件被单独编译（而不是打包），可以将 `builder` 设置为 `"tsc"`（或 `"swc"`），构建过程将改用 TypeScript 编译器。

## Webpack 选项

webpack 配置文件可以包含标准的 [webpack 配置选项](https://webpack.js.org/configuration/)。例如，如果你希望 webpack 打包 `node_modules`（默认会被排除），可以在 `webpack.config.js` 中添加如下内容：

```js
module.exports = {
  externals: [],
}
```

由于 webpack 配置文件本质上是一个 JavaScript 文件，你甚至可以导出一个函数，该函数接收默认选项并返回修改后的对象：

```js
module.exports = function (options) {
  return {
    ...options,
    externals: [],
  }
}
```

## 资源文件

TypeScript 编译器会自动将编译产物（`.js` 和 `.d.ts` 文件）输出到指定目录。同时，你也可以配置它来复制非 TypeScript 文件，例如 `.graphql` 文件、图片、`.html` 文件以及其他静态资源。这样，`nest build` 命令就不仅仅是编译，也承担了轻量级**开发构建**的角色，让你在迭代开发中也能处理非 TS 文件。

资源文件应位于 `src` 文件夹下，否则不会被复制。

`assets` 键的值是一个数组，其中每个元素用于指定要分发的文件。元素可以是简单的 `glob` 风格字符串，例如：

```ts
"assets": ["**/*.graphql"],
"watchAssets": true,
```

如果需要更精细的控制，元素也可以是包含以下键的对象：

- `"include"`：用于指定要分发的资源文件的 `glob` 风格匹配规则
- `"exclude"`：用于指定要从 `include` 列表中**排除**的资源文件的 `glob` 风格匹配规则
- `"outDir"`：字符串，指定资源文件分发的路径（相对于根目录）。默认为编译输出目录。
- `"watchAssets"`：布尔值；若为 `true`，则以监听模式运行，监控指定的资源文件

例如：

```ts
"assets": [
  { "include": "**/*.graphql", "exclude": "**/omitted.graphql", "watchAssets": true },
]
```

<CalloutInfo type="warning">
  如果在顶层 `compilerOptions` 属性中设置了 `watchAssets`，它将覆盖 `assets` 属性中任何
  `watchAssets` 的设置。
</CalloutInfo>

## 项目属性

此元素仅存在于 Monorepo 中。通常不建议修改这些属性，因为 Nest 会使用它们来定位各个项目及其在 Monorepo 中的配置选项。

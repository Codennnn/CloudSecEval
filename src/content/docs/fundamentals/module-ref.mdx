# 模块引用

Nest 提供了 `ModuleRef` 类，用于在应用内部的提供者列表中进行导航，并通过注入令牌（Injection Token）作为查找键，获取任意已注册提供者的实例。此外，`ModuleRef` 还支持动态实例化静态或作用域提供者（Scoped Providers）。你可以像注入其他依赖一样，将 `ModuleRef` 注入到类中使用：

```ts filename='cats.service.ts'
import { ModuleRef } from '@nestjs/core'

@Injectable()
export class CatsService {
  constructor(private moduleRef: ModuleRef) {}
}
```

## 获取实例

`ModuleRef` 实例（下文简称“模块引用”）提供了 `get()` 方法，用于按注入令牌或类名查找并返回当前模块中已注册且已实例化的提供者、控制器或可注入对象（如守卫、拦截器等）。若未找到对应实例，将会抛出异常。

```ts filename='cats.service.ts'
@Injectable()
export class CatsService implements OnModuleInit {
  private service: Service
  constructor(private moduleRef: ModuleRef) {}

  onModuleInit() {
    this.service = this.moduleRef.get(Service)
  }
}
```

<CalloutInfo type="warning">
  `get()`
  方法**无法获取作用域提供者**（例如瞬态或请求作用域的提供者）。有关这类场景，请参见下文的[解析作用域提供者](#resolving-scoped-providers)部分。关于作用域控制的详细说明，参阅[依赖注入作用域](/fundamentals/injection-scopes)。
</CalloutInfo>

如需从**全局上下文**中解析某个提供者（例如该提供者定义在其他模块中），可以通过向 `get()` 方法传入第二个参数 `{ strict: false }` 来关闭严格模式：

```ts
this.moduleRef.get(Service, { strict: false })
```

## 解析作用域提供者

当你需要动态解析作用域提供者（例如瞬态或请求作用域的服务）时，可以使用 `resolve()` 方法，并传入目标提供者的注入令牌：

```ts filename='cats.service.ts'
@Injectable()
export class CatsService implements OnModuleInit {
  private transientService: TransientService

  constructor(private moduleRef: ModuleRef) {}

  async onModuleInit() {
    this.transientService = await this.moduleRef.resolve(TransientService)
  }
}
```

`resolve()` 方法会返回该提供者在其专属依赖注入子树中的唯一实例。每个子树都有独立的上下文标识符（context identifier），因此多次调用该方法时返回的实例并不相同：

```ts filename='cats.service.ts'
@Injectable()
export class CatsService implements OnModuleInit {
  constructor(private moduleRef: ModuleRef) {}

  async onModuleInit() {
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService),
      this.moduleRef.resolve(TransientService),
    ])
    console.log(transientServices[0] === transientServices[1]) // false
  }
}
```

如果希望多次调用 `resolve()` 返回相同的实例（即共享同一个依赖注入子树），可以为 `resolve()` 提供一个上下文标识符。该标识符可通过 `ContextIdFactory.create()` 方法生成：

```ts filename='cats.service.ts'
import { ContextIdFactory } from '@nestjs/core'

@Injectable()
export class CatsService implements OnModuleInit {
  constructor(private moduleRef: ModuleRef) {}

  async onModuleInit() {
    const contextId = ContextIdFactory.create()
    const transientServices = await Promise.all([
      this.moduleRef.resolve(TransientService, contextId),
      this.moduleRef.resolve(TransientService, contextId),
    ])
    console.log(transientServices[0] === transientServices[1]) // true
  }
}
```

## 注册 `REQUEST` 提供者

当你通过 `ContextIdFactory.create()` 手动生成上下文标识符时，Nest 并不会自动将 `REQUEST` 提供者注入到该依赖注入子树中，因此默认情况下该值为 `undefined`。这是因为该上下文并非由 Nest 的请求生命周期自动创建和管理。

如果你希望为这种手动创建的依赖注入上下文提供一个自定义的 `REQUEST` 对象，可以使用 `ModuleRef#registerRequestByContextId()` 方法进行注册：

```ts
const contextId = ContextIdFactory.create();
this.moduleRef.registerRequestByContextId(/* YOUR_REQUEST_OBJECT */, contextId);
```

## 获取当前请求上下文

在某些场景下，你可能需要在请求作用域中解析其他请求作用域的提供者实例。以 `CatsService` 为例，假设它是请求作用域的服务，且你希望在其中获取同为请求作用域的 `CatsRepository` 实例。为了确保它们共享同一个依赖注入上下文，不能重新创建上下文标识符，而应获取当前请求所对应的上下文。

你可以通过注入原始请求对象（通常是来自 HTTP 请求或 RPC 调用）来实现这一目标：

```ts filename='cats.service.ts'
@Injectable()
export class CatsService {
  constructor(@Inject(REQUEST) private request: Record<string, unknown>) {}
}
```

<CalloutInfo>
  关于请求作用域提供者（Request
  Provider）的详细说明，可参考[此章节](/fundamentals/injection-scopes#request-provider)。
</CalloutInfo>

随后，你可以使用 `ContextIdFactory.getByRequest()` 方法，根据请求对象获取对应的上下文标识符，并传递给 `moduleRef.resolve()` 方法，从而解析出属于同一请求上下文的其他提供者：

```ts
const contextId = ContextIdFactory.getByRequest(this.request)
const catsRepository = await this.moduleRef.resolve(CatsRepository, contextId)
```

## 动态实例化自定义类

如果需要动态实例化一个未注册为提供者的类，可以使用模块引用（`ModuleRef`）提供的 `create()` 方法：

```ts filename='cats.service.ts'
@Injectable()
export class CatsService implements OnModuleInit {
  private catsFactory: CatsFactory

  constructor(private moduleRef: ModuleRef) {}

  async onModuleInit() {
    this.catsFactory = await this.moduleRef.create(CatsFactory)
  }
}
```

这种方式允许你在不将类注册为提供者的前提下，通过框架容器按需创建其实例。

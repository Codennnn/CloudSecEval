# 自定义提供者（Custom Provider）

在前文中，我们已经介绍了 **依赖注入（Dependency Injection，DI）** 及其在 Nest 中的应用。例如，[基于构造函数的依赖注入](/providers#dependency-injection) 用于将实例（通常是服务提供者）注入到类中。你可能已经注意到，依赖注入机制在 Nest 核心中扮演着至关重要的角色。此前我们只介绍了一种主要模式。随着应用复杂度提升，你可能需要更灵活地使用 DI 系统，下面我们将深入探讨其更多特性。

## 依赖注入基础

依赖注入是一种 [控制反转（Inversion of Control，IoC）](https://en.wikipedia.org/wiki/Inversion_of_control) 技术，即将依赖项的实例化过程交由 IoC 容器（在本例中为 NestJS 运行时）管理，而不是在代码中手动创建。我们以[提供者章节](/providers) 的示例来分析其工作原理。

首先，定义一个提供者。`@Injectable()` 装饰器会将 `CatsService` 类标记为可由 Nest IoC 容器管理的提供者。

```ts filename='cats.service.ts'
import { Injectable } from '@nestjs/common'
import { Cat } from './interfaces/cat.interface'

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = []

  findAll(): Cat[] {
    return this.cats
  }
}
```

接下来，在控制器类中请求 Nest 注入该提供者：

```ts filename='cats.controller.ts'
import { Controller, Get } from '@nestjs/common'
import { CatsService } from './cats.service'
import { Cat } from './interfaces/cat.interface'

@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll()
  }
}
```

最后，在 Nest IoC 容器中注册该提供者：

```ts filename='app.module.ts'
import { Module } from '@nestjs/common'
import { CatsController } from './cats/cats.controller'
import { CatsService } from './cats/cats.service'

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class AppModule {}
```

那么底层发生了什么？整个流程包含三个关键步骤：

1. 在 `cats.service.ts` 中，`@Injectable()` 装饰器声明 `CatsService` 类可由 Nest IoC 容器管理。
2. 在 `cats.controller.ts` 中，`CatsController` 通过构造函数注入声明依赖于 `CatsService` 注入令牌（Injection Token）：

```ts
  constructor(private catsService: CatsService)
```

3. 在 `app.module.ts` 中，将 `CatsService` 注入令牌与 `cats.service.ts` 文件中的 `CatsService` 类关联。我们将在[下文](#standard-providers)详细介绍这种关联方式（也称为 注册）。

当 Nest IoC 容器实例化 `CatsController` 时，会先查找其依赖项\*。发现依赖 `CatsService` 后，会根据注册步骤（第 3 步）查找 `CatsService` 注入令牌，并返回对应的 `CatsService` 类。若采用默认的 `SINGLETON` 作用域，Nest 会创建 `CatsService` 的实例、缓存并返回，若已缓存则直接返回现有实例。

\*为简化说明，实际依赖分析过程更为复杂，发生在应用启动期间。依赖分析（即“创建依赖图”）是**递归传递**的。例如，如果 `CatsService` 本身还有依赖项，也会被自动解析。依赖图确保依赖项按正确顺序解析 —— 本质上是“自底向上”。这一机制让开发者无需手动管理复杂的依赖关系。

## 标准提供者（Standard Provider）

接下来，我们进一步了解 `@Module()` 装饰器的用法。在 `app.module` 文件中，通常这样声明模块：

```ts
@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
```

`providers` 属性接收一个提供者数组。到目前为止，我们直接通过类名列表传递这些提供者。实际上，`providers: [CatsService]` 是更完整写法的简化形式：

```ts
providers: [
  {
    provide: CatsService,
    useClass: CatsService,
  },
]
```

通过这种显式写法，可以更清晰地理解注册过程。这里，我们将 `CatsService` 作为注入令牌，并关联到 `CatsService` 类本身。简写语法仅用于简化最常见的场景，即通过类名直接请求其实例。

## 自定义提供者（Custom Provider）

如果你的需求超出了 _标准提供者_ 的能力怎么办？例如：

- 希望自定义实例，而不是让 Nest 自动实例化（或返回缓存的）类
- 希望在另一个依赖项中复用已有类
- 希望在测试时用 mock 替换真实类

Nest 允许你通过自定义提供者来满足这些场景。你可以使用多种方式定义自定义提供者，下面将逐一介绍。

<CalloutInfo>
  如果遇到依赖解析相关的问题，可以设置 `NEST_DEBUG` 环境变量，在启动时获取更详细的依赖解析日志。
</CalloutInfo>

## 值提供者：`useValue`

`useValue` 适用于注入常量、集成外部库到 Nest 容器，或在测试中用 mock 对象替换真实实现。例如，若希望在测试时让 Nest 使用 mock 版的 `CatsService`：

```ts
import { CatsService } from './cats.service'

const mockCatsService = {
  /* mock 实现
  ...
  */
}

@Module({
  imports: [CatsModule],
  providers: [
    {
      provide: CatsService,
      useValue: mockCatsService,
    },
  ],
})
export class AppModule {}
```

在上述示例中，`CatsService` 的注入令牌会被解析为 `mockCatsService` mock 对象。`useValue` 需要传入一个值，这里是一个与 `CatsService` 类接口兼容的对象。由于 TypeScript 的[结构类型](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)特性，你可以传入任何接口兼容的对象，包括字面量对象或通过 `new` 实例化的类。

## 非类注入令牌

目前为止，我们一直使用类名作为提供者的注入令牌（即 `provide` 属性的值）。这种方式与[基于构造函数的注入](/providers#dependency-injection)模式相对应，令牌通常为类名。关于令牌的概念，可参考[依赖注入基础](#dependency-injection-fundamentals)。

有时，我们希望使用字符串或 symbol 作为 DI 令牌。例如：

```ts
import { connection } from './connection'

@Module({
  providers: [
    {
      provide: 'CONNECTION',
      useValue: connection,
    },
  ],
})
export class AppModule {}
```

在此示例中，我们用字符串类型的令牌（`'CONNECTION'`）关联已有的 `connection` 对象。

<CalloutInfo type="warning">
  除了字符串，还可以使用 JavaScript
  [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
  或 TypeScript [enum](https://www.typescriptlang.org/docs/handbook/enums.html) 作为令牌。
</CalloutInfo>

前文已介绍如何通过标准[构造函数注入](/providers#dependency-injection)模式注入提供者。该模式要求依赖项以类名声明。而 `'CONNECTION'` 这样的自定义提供者使用字符串令牌。要注入此类提供者，需要使用 `@Inject()` 装饰器，并传入令牌作为参数。

```ts
import { Inject, Injectable } from '@nestjs/common'

@Injectable()
export class CatsRepository {
  constructor(@Inject('CONNECTION') connection: Connection) {}
}
```

虽然上例直接使用了字符串 `'CONNECTION'`，但为了代码整洁，建议将令牌定义在单独的文件（如 `constants.ts`），集中管理和导入，无论是 symbol 还是 enum。

## 类提供者：`useClass`

`useClass` 语法允许你动态决定令牌应解析为哪个类。例如，假设有一个抽象（或默认）`ConfigService` 类。根据当前环境，Nest 可提供不同的配置服务实现。如下：

```ts
const configServiceProvider = {
  provide: ConfigService,
  useClass:
    process.env.NODE_ENV === 'development' ? DevelopmentConfigService : ProductionConfigService,
}

@Module({
  providers: [configServiceProvider],
})
export class AppModule {}
```

此代码中，我们先用字面量对象定义 `configServiceProvider`，再传给模块装饰器的 `providers` 属性。这只是代码组织方式，功能等同于前文示例。

此外，我们用 `ConfigService` 类名作为令牌。依赖 `ConfigService` 的类会注入所提供的实现类（`DevelopmentConfigService` 或 `ProductionConfigService`），覆盖其他地方声明的默认实现（如用 `@Injectable()` 装饰器声明的 `ConfigService`）。

## 工厂提供者：`useFactory`

`useFactory` 语法用于**动态**创建提供者。实际提供者由工厂函数的返回值决定。工厂函数既可以简单，也可以复杂。简单工厂无需依赖其他提供者，复杂工厂则可注入其他依赖。实现方式如下：

1. 工厂函数可接收（可选）参数。
2. `inject` 属性（可选）接收一个提供者数组，Nest 会在实例化时解析这些依赖，并按顺序传递给工厂函数。这些依赖项也可以被标记为可选。示例如下：

```ts
const connectionProvider = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider: MyOptionsProvider, optionalProvider?: string) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [MyOptionsProvider, { token: 'SomeOptionalProvider', optional: true }],
  //       \______________/             \__________________/
  //        必需依赖项                    可选依赖项，可能为 undefined
}

@Module({
  providers: [
    connectionProvider,
    MyOptionsProvider, // 基于类的提供者
    // { provide: 'SomeOptionalProvider', useValue: 'anything' },
  ],
})
export class AppModule {}
```

```js hideInDoc
const connectionProvider = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider, optionalProvider) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [MyOptionsProvider, { token: 'SomeOptionalProvider', optional: true }],
  //       \______________/            \__________________/
  //        必需依赖项                   可选依赖项，可能为 undefined
}

@Module({
  providers: [
    connectionProvider,
    MyOptionsProvider, // 基于类的提供者
    // { provide: 'SomeOptionalProvider', useValue: 'anything' },
  ],
})
export class AppModule {}
```

## 别名提供者：`useExisting`

`useExisting` 语法用于为已有提供者创建别名。这样可以通过不同的令牌访问同一个提供者。例如，字符串令牌 `'AliasedLoggerService'` 是类令牌 `LoggerService` 的别名。假如有两个依赖项分别依赖 `'AliasedLoggerService'` 和 `LoggerService`，且都为 `SINGLETON` 作用域，则解析为同一实例。

```ts
@Injectable()
class LoggerService {
  /* 实现细节 */
}

const loggerAliasProvider = {
  provide: 'AliasedLoggerService',
  useExisting: LoggerService,
}

@Module({
  providers: [LoggerService, loggerAliasProvider],
})
export class AppModule {}
```

## 非服务类提供者

虽然提供者通常用于注入服务，但它们并不仅限于此。实际上，提供者可以用于注入任意值。例如，可以根据当前环境动态提供配置对象数组：

```ts
const configFactory = {
  provide: 'CONFIG',
  useFactory: () => {
    return process.env.NODE_ENV === 'development' ? devConfig : prodConfig
  },
}

@Module({
  providers: [configFactory],
})
export class AppModule {}
```

## 导出自定义提供者

与其他提供者一样，自定义提供者的作用域默认仅限于声明它的模块。若需在其他模块中使用，必须将其导出。可以通过令牌或完整的提供者对象进行导出。

以下示例展示了通过令牌导出：

```ts
const connectionFactory = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider: OptionsProvider) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [OptionsProvider],
}

@Module({
  providers: [connectionFactory],
  exports: ['CONNECTION'],
})
export class AppModule {}
```

```js hideInDoc
const connectionFactory = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [OptionsProvider],
}

@Module({
  providers: [connectionFactory],
  exports: ['CONNECTION'],
})
export class AppModule {}
```

也可以直接导出完整的提供者对象：

```ts
const connectionFactory = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider: OptionsProvider) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [OptionsProvider],
}

@Module({
  providers: [connectionFactory],
  exports: [connectionFactory],
})
export class AppModule {}
```

```js hideInDoc
const connectionFactory = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [OptionsProvider],
}

@Module({
  providers: [connectionFactory],
  exports: [connectionFactory],
})
export class AppModule {}
```

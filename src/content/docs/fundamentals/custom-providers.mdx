# 自定义提供者

在前文中，我们已经介绍过 Nest 中的**依赖注入**机制及其基本用法。例如，[构造函数注入](/providers#dependency-injection)是最常见的形式之一，允许我们将服务实例直接注入到类中。这种机制是 Nest 框架的核心基石。

不过，前面的示例仅涵盖了最基础的场景，随着项目规模的扩展与业务逻辑的复杂化，开发者往往需要更灵活的依赖配置方式。因此，本节将深入介绍依赖注入的底层原理与高级用法，帮助你更好地掌控这一机制。

## 依赖注入基础

依赖注入是控制反转的一种实现方式，它的核心思想是：将依赖的创建与管理交由框架负责，而不是在代码中显式实例化对象。在 Nest 中，这一职责由运行时的 IoC 容器承担。

我们继续沿用提供者章节中的示例，来演示基本的注入流程。

首先，定义一个服务类，并使用 `@Injectable()` 装饰器将其声明为 Nest 管理的提供者：

```ts filename='cats.service.ts'
import { Injectable } from '@nestjs/common'
import { Cat } from './interfaces/cat.interface'

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = []

  findAll(): Cat[] {
    return this.cats
  }
}
```

然后，在控制器中通过构造函数注入该服务：

```ts filename='cats.controller.ts'
import { Controller, Get } from '@nestjs/common'
import { CatsService } from './cats.service'
import { Cat } from './interfaces/cat.interface'

@Controller('cats')
export class CatsController {
  constructor(private catsService: CatsService) {}

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll()
  }
}
```

最后，需要在模块中显式注册这个服务提供者：

```ts filename='app.module.ts'
import { Module } from '@nestjs/common'
import { CatsController } from './cats/cats.controller'
import { CatsService } from './cats/cats.service'

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class AppModule {}
```

### 注入流程解析

上面的代码背后，Nest 实际上完成了以下三个关键步骤：

1. **定义提供者**
   在 `cats.service.ts` 文件中，`@Injectable()` 装饰器将 `CatsService` 声明为由 IoC 容器托管的提供者。
2. **声明依赖关系**
   在控制器 `CatsController` 的构造函数中，声明了对 `CatsService` 的依赖。Nest 会根据构造函数参数的类型推断出所需的依赖，并自动注入对应的实例：

```ts
  constructor(private catsService: CatsService)
```

3. **模块注册**
   在 `app.module.ts` 中，`CatsService` 被添加到模块的 `providers` 数组中。Nest 会将该类的类型作为注入令牌（Injection Token），并据此完成依赖绑定。

当 Nest 创建 `CatsController` 实例时，会先检查它所依赖的服务。发现它依赖 `CatsService` 后，Nest 会根据已注册的提供者信息找到对应的注入令牌，进而实例化 `CatsService` 并注入。如果该服务采用默认的**单例作用域**，则其实例会被缓存起来，后续请求将复用这个实例；若已缓存，则直接返回。

实际上，Nest 在应用启动阶段就会构建整个**依赖图**（Dependency Graph），并解析所有提供者之间的依赖关系。如果某个服务本身还依赖其他服务，Nest 会递归处理这些依赖项，确保它们按照正确的顺序被初始化。整个过程遵循“**自底向上**”的构建逻辑，开发者无需手动管理复杂的依赖链，极大提升了系统的可维护性与模块化能力。

## 标准提供者

接下来，我们来看 `@Module()` 装饰器中 `providers` 属性的典型用法。以 `app.module.ts` 为例，模块通常这样声明：

```ts
@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
```

这里的 `providers` 接收一个提供者数组。到目前为止，我们使用了最常见的简写形式：直接传入类名列表，例如 `CatsService`。实际上，这种写法是以下完整形式的语法糖：

```ts
providers: [
  {
    provide: CatsService,
    useClass: CatsService,
  },
]
```

这种显式写法有助于我们更直观地理解 Nest 如何注册提供者：使用 `CatsService` 作为注入令牌（token），并将其绑定到对应的类定义。简写形式虽然更简洁，但仅适用于最基本的情况——即类名与注入令牌一致，且直接通过类来实例化。

## 自定义提供者

当默认的提供者机制无法满足你的特定需求时，可以通过自定义提供者来获得更大的灵活性。例如，以下场景可能就需要使用**自定义提供者**：

- 你希望手动创建类的实例，而不是让 Nest 自动实例化或使用已有缓存
- 你想在某个依赖项中复用一个已存在的类实例
- 在测试中希望用 mock 实例替代实际类，以便进行更可控的测试

针对这些高级用例，Nest 提供了多种方式来自定义提供者，接下来我们将逐一介绍这些实现方式。

<CalloutInfo>
  如果在开发过程中遇到依赖解析相关的问题，可以通过设置环境变量 `NEST_DEBUG`
  来开启详细的依赖注入日志，便于排查问题。
</CalloutInfo>

## 值提供者：`useValue`

当你需要将一个常量、外部库对象或 mock 实现注入到 Nest 的依赖注入容器中时，可以使用 `useValue` 提供者。它适用于以下场景：

- 注入配置对象或常量值
- 集成第三方库（如数据库客户端、日志工具等）
- 在测试中用 mock 替代真实服务

例如，下面的代码展示了如何在测试中用一个模拟版本的 `CatsService` 替代其真实实现：

```ts
import { CatsService } from './cats.service'

const mockCatsService = {
  // 模拟方法实现
  // ...
}

@Module({
  imports: [CatsModule],
  providers: [
    {
      provide: CatsService,
      useValue: mockCatsService,
    },
  ],
})
export class AppModule {}
```

在这个示例中，我们通过 `useValue` 显式指定，当注入 `CatsService` 时应使用 `mockCatsService`。这个 mock 对象需要与 CatsService 的接口结构兼容。

由于 TypeScript 使用的是[结构化类型系统](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)，只要对象具有相同的结构，就可以视为兼容类型。因此，你可以传入对象字面量，也可以使用类实例（如 `new MockCatsService()`）作为 `useValue` 的值。

## 非类注入令牌

在前面的示例中，我们始终使用类名作为注入令牌（即 `provide` 属性的值）。这种方式符合[基于构造函数的依赖注入](/providers#dependency-injection)模式，令牌本身通常就是类的构造函数。关于注入令牌的基础知识，可参考[依赖注入基础](#dependency-injection-fundamentals)。

然而，在某些场景中，我们可能希望使用字符串、symbol 或 enum 等非类类型作为依赖注入的令牌。例如：

```ts
import { connection } from './connection'

@Module({
  providers: [
    {
      provide: 'CONNECTION',
      useValue: connection,
    },
  ],
})
export class AppModule {}
```

在上述代码中，我们使用字符串 `'CONNECTION'` 作为注入令牌，并将其绑定到一个已有的 `connection` 对象。

<CalloutInfo type="warning">
  除了字符串之外，Nest 也支持使用 JavaScript 的
  [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)
  或 TypeScript 的
  [Enum](https://www.typescriptlang.org/docs/handbook/enums.html) 作为注入令牌。
</CalloutInfo>

我们已经介绍过标准的[构造函数注入](/providers#dependency-injection)方式，在该模式下，依赖项的令牌通常为类名。而当使用 `'CONNECTION'` 这类自定义令牌时，必须通过 `@Inject()` 装饰器显式指定令牌：

```ts
import { Inject, Injectable } from '@nestjs/common'

@Injectable()
export class CatsRepository {
  constructor(@Inject('CONNECTION') connection: Connection) {}
}
```

虽然上例中直接使用了字符串字面量 `'CONNECTION'`，但为了增强代码的可维护性与一致性，推荐将所有自定义令牌集中定义在一个常量文件（如 `constants.ts`）中，无论它们是字符串、symbol，还是 enum 类型。

## 类提供者：`useClass`

使用 `useClass` 可以在运行时动态决定某个依赖注入令牌应绑定的类。这在需要根据环境或配置切换实现时尤为有用。例如，假设我们定义了一个抽象的 `ConfigService` 接口或基类，Nest 可以根据当前环境注入对应的实现类：

```ts
const configServiceProvider = {
  provide: ConfigService,
  useClass:
    process.env.NODE_ENV === 'development'
      ? DevelopmentConfigService
      : ProductionConfigService,
}

@Module({
  providers: [configServiceProvider],
})
export class AppModule {}
```

在上述代码中，我们通过一个字面量对象定义了提供者，并将其传入模块的 `providers` 数组中。这种写法仅是代码组织方式的不同，其功能与直接在 `providers` 中内联定义是等效的。

需要注意，这里我们以 `ConfigService` 作为注入令牌。凡是声明依赖 `ConfigService` 的类，最终都会被注入实际配置的实现类（即 `DevelopmentConfigService` 或 `ProductionConfigService`）。这将覆盖该令牌在其他地方通过 `@Injectable()` 默认声明的实现。

## 工厂提供者：`useFactory`

`useFactory` 允许你通过工厂函数动态创建提供者实例，适用于在运行时根据某些逻辑生成依赖的场景。工厂函数的返回值将作为提供者的实际内容，可以非常简单，也可以包含依赖注入、条件分支等复杂逻辑。

在使用 `useFactory` 时，常见的用法要点包括：

- 工厂函数可以选择性地接收参数。
- 若工厂函数依赖其他服务，可以通过 `inject` 属性指定所需的依赖，Nest 会在调用工厂函数时自动注入这些依赖项，并按照顺序传入。
- 支持可选依赖的声明，Nest 会在缺失时传入 `undefined`，而不会抛出异常。

下面是一个典型示例：

```ts
const connectionProvider = {
  provide: 'CONNECTION',
  useFactory: (
    optionsProvider: MyOptionsProvider,
    optionalProvider?: string
  ) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [
    MyOptionsProvider,
    { token: 'SomeOptionalProvider', optional: true },
  ],
  //       \______________/             \__________________/
  //        必需依赖项                    可选依赖项，可能为 undefined
}

@Module({
  providers: [
    connectionProvider,
    MyOptionsProvider, // 基于类的提供者
    // { provide: 'SomeOptionalProvider', useValue: 'anything' },
  ],
})
export class AppModule {}
```

在这个例子中，`useFactory` 所定义的工厂函数依赖一个配置服务 `MyOptionsProvider`，并可能依赖另一个可选的提供者 `'SomeOptionalProvider'`。Nest 会根据 `inject` 数组自动解析并注入这些依赖，无需手动调用或处理。

## 别名提供者：`useExisting`

在某些场景中，我们可能希望通过多个令牌访问同一个服务实例，而不必重复声明或实例化。Nest 提供的 `useExisting` 选项，正是用于为已有提供者创建别名的一种方式。

通过 `useExisting`，我们可以将一个新的令牌指向某个已存在的提供者，从而让依赖注入系统在解析这两个令牌时返回相同的实例。前提是该服务的作用域为单例，否则将无法实现实例共享。

来看一个示例：

```ts
@Injectable()
class LoggerService {
  /* 实现细节 */
}

const loggerAliasProvider = {
  provide: 'AliasedLoggerService',
  useExisting: LoggerService,
}

@Module({
  providers: [LoggerService, loggerAliasProvider],
})
export class AppModule {}
```

在上述代码中，我们将字符串令牌 `'AliasedLoggerService'` 定义为 `LoggerService` 的别名。此后，凡是通过 `'AliasedLoggerService'` 或 `LoggerService` 注入依赖的地方，都将获得同一个 `LoggerService` 实例。

## 非服务类提供者

虽然“提供者”这个术语常用于注入服务，但它的应用远不止于此。事实上，提供者可以用于注入任何类型的值——包括对象、函数、常量，甚至是根据运行时环境动态生成的内容。

例如，以下代码展示了如何根据当前的环境变量动态注入一组配置对象：

```ts
const configFactory = {
  provide: 'CONFIG',
  useFactory: () => {
    return process.env.NODE_ENV === 'development' ? devConfig : prodConfig
  },
}

@Module({
  providers: [configFactory],
})
export class AppModule {}
```

## 导出自定义提供者

自定义提供者与其他提供者一样，其默认作用域仅限于声明它的模块内部。如果希望在其他模块中复用这些提供者，必须显式将它们导出。

你可以选择按“令牌（token）”导出，也可以直接导出完整的提供者对象：

### 使用令牌导出

下面的示例中，我们通过字符串令牌 `'CONNECTION'` 导出一个基于工厂函数的自定义提供者：

```ts
const connectionFactory = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider: OptionsProvider) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [OptionsProvider],
}

@Module({
  providers: [connectionFactory],
  exports: ['CONNECTION'],
})
export class AppModule {}
```

### 使用对象导出

也可以直接将整个提供者对象添加到 `exports` 数组中，效果与通过令牌导出相同：

```ts
const connectionFactory = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider: OptionsProvider) => {
    const options = optionsProvider.get()
    return new DatabaseConnection(options)
  },
  inject: [OptionsProvider],
}

@Module({
  providers: [connectionFactory],
  exports: [connectionFactory],
})
export class AppModule {}
```

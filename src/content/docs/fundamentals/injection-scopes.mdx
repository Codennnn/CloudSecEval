# 依赖注入的作用域

对于来自其他编程语言的开发者来说，Nest 中“几乎所有内容在请求之间是共享的”这一特性可能颇感意外。常见示例包括数据库连接池、全局状态服务等单例对象。在理解这一点之前，有必要澄清一个常见误区：**Node.js 并非基于“每个请求由独立线程处理”的无状态模型**。也就是说，同一个服务实例会被多个请求复用，而非为每个请求创建新的线程与实例。

正因为如此，Nest 默认采用单例模式注入依赖，这是安全且高效的做法，尤其适用于绝大多数业务场景。

不过，在某些特殊需求下，例如 GraphQL 应用中的请求级缓存、请求追踪或多租户（multi-tenancy）支持，我们希望每个请求拥有独立的服务实例。这时，就可以通过**依赖注入作用域**机制，对提供者的生命周期进行更精细的控制。

## 提供者作用域

Nest 提供了三种作用域配置，用于定义提供者的生命周期和复用策略：

| 作用域      | 说明                                                                                                               |
| ----------- | ------------------------------------------------------------------------------------------------------------------ |
| `DEFAULT`   | 默认作用域，提供者为全局单例。生命周期与应用一致，在应用启动时创建，仅实例化一次，后续请求与消费者都会复用该实例。 |
|             |
| `REQUEST`   | 请求作用域。每次请求都会创建该提供者的新实例，请求处理完毕后自动销毁。适用于与请求强相关的上下文数据或状态隔离。   |
|             |
| `TRANSIENT` | 瞬态作用域。每次注入都会创建一个全新的实例，完全不共享状态，适合需要高度隔离的逻辑或临时对象。                     |

<CalloutInfo type="success">
  在绝大多数情况下，优先使用默认的单例作用域。它不仅能在多个请求和消费者之间高效复用，还能显著降低资源消耗，因为只在应用启动时初始化一次。
</CalloutInfo>

## 用法

你可以通过在 `@Injectable()` 装饰器的配置对象中指定 `scope` 属性，来设置该类在依赖注入中的作用域：

```ts filename='cats.service.ts'
import { Injectable, Scope } from '@nestjs/common'

@Injectable({ scope: Scope.REQUEST })
export class CatsService {}
```

对于[自定义提供者](/fundamentals/custom-providers)，也同样支持通过完整的注册形式设置 `scope`：

```ts
{
  provide: 'CACHE_MANAGER',
  useClass: CacheManager,
  scope: Scope.TRANSIENT,
}
```

<CalloutInfo>需要从 `@nestjs/common` 导入 `Scope` 枚举。</CalloutInfo>

默认情况下，所有提供者均为单例作用域，通常不需要显式声明。如果需要，也可以通过设置为 `Scope.DEFAULT` 来明确指定为默认作用域。

<CalloutInfo type="warning">
  **WebSocket
  网关不支持请求作用域（Request-scoped）提供者**。网关必须作为单例存在，因为每个网关实例都封装了一个底层
  socket 对象，无法被重复创建。类似的限制也适用于其他某些类型的提供者，例如
  [Passport 策略](/security/authentication#request-scoped-strategies) 或 Cron
  控制器。
</CalloutInfo>

## 控制器作用域

与提供者类似，控制器同样支持作用域配置。控制器的作用域不仅影响其所有的请求处理方法，还决定了控制器实例的生命周期管理方式。

当控制器被设置为**请求作用域**（`Scope.REQUEST`）时，Nest 会在每次接收到入站请求时创建一个新的控制器实例，并在该请求处理完毕后自动销毁。这种方式适用于需要隔离请求状态或依赖请求上下文的场景，例如每个请求都需注入不同的用户信息、权限数据等。

要配置控制器的作用域，可以通过 `ControllerOptions` 中的 `scope` 属性进行设置：

```ts filename='cats.controller.ts'
@Controller({
  path: 'cats',
  scope: Scope.REQUEST,
})
export class CatsController {}
```

## 作用域的层级

在 Nest 中，`REQUEST`（请求）作用域具备向上传播的特性：**一旦某个提供者被标记为请求作用域，其依赖链上的所有上层提供者也会自动转为请求作用域**。

举个例子，设有如下依赖关系：`CatsController <- CatsService <- CatsRepository`。如果将 `CatsService` 声明为请求作用域，即使 `CatsController` 原本是默认的单例作用域，它也会因依赖了请求作用域的 `CatsService` 而自动转变为请求作用域。而 `CatsRepository` 并未依赖任何请求作用域的提供者，因此它仍保持默认的单例作用域不变。

相比之下，`TRANSIENT`（瞬态）作用域的行为截然不同：**瞬态作用域不会影响其上层依赖者的作用域**。
比如，一个单例作用域的 `DogsService` 注入了一个瞬态的 `LoggerService`，每次注入时都会创建新的 `LoggerService` 实例，但 `DogsService` 自身依然是单例，它在整个应用中始终只会有一个实例。

如果你希望每次注入 `DogsService` 时都生成一个全新的实例，就必须**显式将其声明为瞬态作用域**。

## 请求对象的注入方式

在基于 HTTP 的应用中（如使用 `@nestjs/platform-express` 或 `@nestjs/platform-fastify`），若需在**请求作用域的提供者**中访问原始的请求对象，可通过注入内置的 `REQUEST` 提供者实现。

`REQUEST` 自身即为请求作用域，因此**无需也无法手动设置其作用域** —— 即使显式指定也不会生效。与此同时，凡是依赖请求作用域提供者的类，也会**自动转为请求作用域**，这是框架层面的默认行为，无法被覆盖。

```ts
import { Injectable, Scope, Inject } from '@nestjs/common'
// [!code word:REQUEST:1]
import { REQUEST } from '@nestjs/core'
import { Request } from 'express'

@Injectable({ scope: Scope.REQUEST })
export class CatsService {
  // [!code word:REQUEST:1]
  constructor(@Inject(REQUEST) private request: Request) {}
}
```

需要注意的是，在非 HTTP 场景（如微服务或 GraphQL）中，因底层平台或协议不同，请求对象的注入方式也有所差异。以 GraphQL 为例，应使用 `CONTEXT` 而非 `REQUEST`：

```ts
// [!code word:CONTEXT]
import { Injectable, Scope, Inject } from '@nestjs/common'
import { CONTEXT } from '@nestjs/graphql'

@Injectable({ scope: Scope.REQUEST })
export class CatsService {
  constructor(@Inject(CONTEXT) private context) {}
}
```

此外，还需要在 `GraphQLModule` 中的 `context` 配置项中，**显式将请求对象传入上下文**，以便后续在服务中访问。

## Inquirer 提供者

在某些场景下，我们可能希望在一个提供者被实例化时，获取其“注入来源”——即该提供者是被哪个类注入的。这在进行日志记录、性能追踪或依赖链分析等场景中尤为有用。Nest 提供了一个内置的标识符 `INQUIRER`，用于在构造函数中注入当前实例的注入方（`inquirer`）。

```ts filename='hello.service.ts'
import { Inject, Injectable, Scope } from '@nestjs/common'
// [!code word:INQUIRER]
import { INQUIRER } from '@nestjs/core'

@Injectable({ scope: Scope.TRANSIENT })
export class HelloService {
  constructor(@Inject(INQUIRER) private parentClass: object) {}

  sayHello(message: string) {
    console.log(`${this.parentClass?.constructor?.name}: ${message}`)
  }
}
```

使用示例：

```ts
import { Injectable } from '@nestjs/common'
import { HelloService } from './hello.service'

@Injectable()
export class AppService {
  constructor(private helloService: HelloService) {}

  getRoot(): string {
    this.helloService.sayHello('My name is getRoot')
    return 'Hello world!'
  }
}
```

当调用 `AppService#getRoot()` 方法时，`HelloService` 会通过 `INQUIRER` 注入得知它是由 `AppService` 所创建，因此控制台将输出：

```
AppService: My name is getRoot
```

## 性能考量

启用请求作用域的提供者会对应用性能造成一定影响。尽管 Nest 会尽量复用元数据以降低开销，但每次请求仍需创建新的类实例，这会提高平均响应时间，并可能拉低基准测试成绩。因此，**除非确有必要，强烈建议优先使用默认的单例作用域**。

<CalloutInfo>
  虽然请求作用域带来一定的性能损耗，但在架构合理的应用中，即使大量使用请求作用域提供者，整体延迟一般不会超过
  5%。
</CalloutInfo>

## 持久化提供者

要使用持久化提供者，需先注册一个**上下文分组策略**（ContextIdStrategy），告知 Nest 应如何根据“通用请求属性”分组，并为每组生成独立的依赖注入子树。

如前所述，请求作用域提供者的性能开销不可忽视。一旦某个请求作用域的提供者被注入到控制器或其依赖链中，该控制器也会被标记为请求作用域。这意味着每次请求都会重新实例化控制器及其所有依赖项，并在请求结束后统一销毁。假设系统同时处理 3 万个并发请求，等同于在内存中同时存在 3 万份控制器实例及其依赖，资源消耗可想而知。

在实际开发中，我们常常会遇到一些被广泛依赖的基础服务，例如数据库连接、日志记录器等。如果将这类服务设计为请求作用域，那么所有依赖它们的组件也将被隐式设为请求作用域。在多租户（Multi-Tenant）架构中尤为常见，尤其是当你需要基于请求头或 Token 动态选择数据库连接或 Schema 时，往往会定义一个“中心化”的数据源提供者。

以多租户场景为例，假设系统服务 10 个客户，每个客户都有独立的数据源。为了避免数据串用，你可能希望根据每个请求中的租户标识动态选择对应的数据源。常见做法是声明一个请求作用域的数据源提供者，在每次请求中提取租户信息，并绑定合适的数据库连接。这种方式虽然易于实现，但由于该提供者被广泛依赖，会导致整个应用大面积进入请求作用域，最终影响整体性能。

有没有更高效的替代方案？如果你的客户数量是有限的（比如只有 10 个租户），完全可以为每个租户构建一棵独立的依赖注入子树，而不是每次请求都动态构建整个依赖关系。只要依赖关系可以按“租户 ID”这样的通用属性归类，而不是基于每个请求唯一的字段（如 UUID），就没必要为每个请求都创建新的上下文。

这正是**持久化提供者**（Durable Providers）设计的初衷。

### 上下文分组策略

要启用持久化提供者，需要定义一个上下文分组策略，用于告诉 Nest 应该如何根据请求中的某些公共属性来分组请求，并为每个分组创建独立的依赖注入子树。

示例代码如下：

```ts
import {
  HostComponentInfo,
  ContextId,
  ContextIdFactory,
  ContextIdStrategy,
} from '@nestjs/core'
import { Request } from 'express'

const tenants = new Map<string, ContextId>()

export class AggregateByTenantContextIdStrategy implements ContextIdStrategy {
  attach(contextId: ContextId, request: Request) {
    const tenantId = request.headers['x-tenant-id'] as string
    let tenantSubTreeId: ContextId

    if (tenants.has(tenantId)) {
      tenantSubTreeId = tenants.get(tenantId)
    } else {
      tenantSubTreeId = ContextIdFactory.create()
      tenants.set(tenantId, tenantSubTreeId)
    }

    // 返回用于标识当前宿主组件所用上下文 ID 的函数
    return (info: HostComponentInfo) =>
      info.isTreeDurable ? tenantSubTreeId : contextId
  }
}
```

<CalloutInfo>
  与请求作用域类似，durable 属性也会在依赖链中向上传递。即：若组件 A 依赖于一个
  `durable: true` 的组件 B，则 A 默认也会被视为 durable，除非显式设置 `durable:
  false`。
</CalloutInfo>

<CalloutInfo type="warning">
  如果系统包含数量巨大的租户，请谨慎使用该策略，以避免内存管理复杂化。
</CalloutInfo>

### 注册上下文策略与使用 payload

上面的 `attach` 方法默认仅返回一个函数，用于告诉 Nest 哪个 `ContextId` 应用于当前宿主组件。你也可以扩展其返回值，加入 `payload` 信息（例如当前的租户 ID），从而让你在服务中通过 `@Inject(REQUEST)` 或 `@Inject(CONTEXT)` 获取附加数据：

```ts
return {
  resolve: (info: HostComponentInfo) =>
    info.isTreeDurable ? tenantSubTreeId : contextId,
  payload: { tenantId },
}
```

完成策略定义后，你需要在应用启动时注册该策略，确保其在请求处理之前生效：

```ts filename='main.ts'
import { ContextIdFactory } from '@nestjs/core'

ContextIdFactory.apply(new AggregateByTenantContextIdStrategy())
```

### 标记 Durable 提供者

你可以通过设置 `durable: true` 将某个请求作用域的提供者标记为持久化：

```ts
import { Injectable, Scope } from '@nestjs/common'

@Injectable({ scope: Scope.REQUEST, durable: true })
export class CatsService {}
```

对于[自定义提供者](/fundamentals/custom-providers)，也可在配置中添加 `durable` 属性：

```ts
{
  provide: 'foobar',
  useFactory: () => { ... },
  scope: Scope.REQUEST,
  durable: true,
}
```

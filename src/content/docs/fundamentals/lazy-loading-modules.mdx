# 懒加载模块

在 Nest 应用中，所有模块默认会**急切加载**（eagerly loaded），也就是说，无论是否立即使用，应用在启动时会加载所有模块。对于大多数应用场景，这种行为通常不会带来问题。然而，在无服务器（Serverless）环境或基于 Worker 的架构中，启动延迟（即“冷启动”）对性能影响显著，此时急切加载可能成为性能瓶颈。

通过启用懒加载（Lazy Loading），应用只会加载当前 serverless 函数调用所需的模块，从而显著减少启动时间。你还可以在函数预热阶段异步加载其他模块（即延迟注册），进一步优化后续请求的响应速度。

<CalloutInfo>
  如果你熟悉 [Angular](https://angular.dev/)
  框架，可能见过“[懒加载模块](https://angular.dev/guide/ngmodules/lazy-loading#lazy-loading-basics)”的概念。请注意，虽然命名相似，**Nest
  中的懒加载实现机制与 Angular 完全不同**，两者的功能与底层逻辑并不相同。
</CalloutInfo>

<CalloutInfo type="warning">
  使用懒加载模块或服务时，[生命周期钩子方法](/fundamentals/lifecycle-events)将不会被调用。
</CalloutInfo>

## 快速上手

Nest 提供了 `LazyModuleLoader` 类，用于实现模块的按需加载。你可以像注入其他依赖一样，将其注入到服务类中：

```ts filename='cats.service.ts'
import { LazyModuleLoader } from '@nestjs/core'

@Injectable()
export class CatsService {
  constructor(private lazyModuleLoader: LazyModuleLoader) {}
}
```

除了在类中注入，你也可以在应用的入口文件（`main.ts`）中手动获取 `LazyModuleLoader` 实例：

```ts filename='main.ts'
// `app` 为 Nest 应用实例
const lazyModuleLoader = app.get(LazyModuleLoader)
```

获得 `lazyModuleLoader` 后，你就可以通过以下方式动态加载模块：

```ts
const { LazyModule } = await import('./lazy.module')
const moduleRef = await this.lazyModuleLoader.load(() => LazyModule)
```

<CalloutInfo>
懒加载模块在首次通过 `LazyModuleLoader#load` 方法加载时会被缓存。因此，后续加载同一模块时速度极快，且直接返回已缓存的模块引用，无需重复加载。

```bash
第 1 次加载 "LazyModule"
time: 2.379ms
第 2 次加载 "LazyModule"
time: 0.294ms
第 3 次加载 "LazyModule"
time: 0.303ms
```

此外，懒加载模块会与应用启动时急切加载的模块，以及后续加载的其他懒加载模块，共享同一个模块图（module graph）。

</CalloutInfo>

被加载的 `lazy.module.ts` 文件应导出一个标准的 Nest 模块，无需进行额外修改。

通过 `LazyModuleLoader`#load 方法返回的模块引用（ModuleRef），你可以访问模块内部的所有提供者，并通过注入令牌获取其实例。

例如，假设我们有以下定义的 `LazyModule`：

```ts filename='lazy.module.ts'
@Module({
  providers: [LazyService],
  exports: [LazyService],
})
export class LazyModule {}
```

<CalloutInfo>
  懒加载模块不能注册为**全局模块**，因为它们在所有静态模块实例化之后才会被加载。同样地，无法用于注册**全局增强器**（如守卫、拦截器等），这些增强器的注册时机要求在应用启动阶段完成。
</CalloutInfo>

此时我们就可以通过模块引用来获取 `LazyService` 实例：

```ts
const { LazyModule } = await import('./lazy.module')
const moduleRef = await this.lazyModuleLoader.load(() => LazyModule)

const { LazyService } = await import('./lazy.service')
const lazyService = moduleRef.get(LazyService)
```

<CalloutInfo type="warning">
  如果你使用的是 Webpack，请确保在 `tsconfig.json` 中设置以下编译选项：

```json
 {
   "compilerOptions": {
     "module": "esnext",
     "moduleResolution": "node",
     ...
   }
 }
```

配置完成后，即可使用 Webpack 的[代码分割（code splitting）](https://webpack.js.org/guides/code-splitting/)功能，实现更高效的懒加载。

</CalloutInfo>

## 懒加载控制器、网关与解析器

在 Nest 中，控制器或 GraphQL 应用中的解析器（Resolver）负责处理一组路由、路径、主题，或 GraphQL 查询与变更。需要注意的是，无法通过 `LazyModuleLoader` 对它们进行懒加载。

<CalloutInfo type="warning">
  在懒加载模块中注册的控制器、[解析器](/graphql/resolvers)及[网关](/websockets/gateways)
  均无法按预期正常工作。同时，基于 `MiddlewareConsumer` 接口实现的中间件函数也无法按需注册。
</CalloutInfo>

举例来说，如果你使用 Fastify 驱动（`@nestjs/platform-fastify`）构建 REST API（HTTP 应用），由于 Fastify 不支持应用启动后动态注册路由，即使分析了模块中控制器的路由映射，懒加载的路由在运行时依然无法访问。

类似地，`@nestjs/microservices` 中的某些传输层（如 Kafka、gRPC、RabbitMQ）要求在连接建立前完成主题或通道的订阅。一旦应用开始监听消息，框架就无法再动态订阅新的主题。

此外，`@nestjs/graphql` 在启用 code-first 模式时，会基于元数据动态生成 GraphQL schema，这就要求所有相关类必须在启动时被提前加载，否则无法正确生成有效的 schema。

## 常见使用场景

懒加载模块一般适用于如下场景：worker 进程、定时任务（cron job）、Lambda 及 Serverless 函数、Webhook 等场景，这些场景往往需要根据输入参数（如路由路径、日期、查询参数等）动态触发不同的服务逻辑。对于启动时间要求不高的单体应用，懒加载模块的优势并不明显。

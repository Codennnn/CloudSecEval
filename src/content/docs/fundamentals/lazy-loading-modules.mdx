# 懒加载模块

默认情况下，Nest 应用会**急切加载**（eagerly loaded）所有模块，也就是说，应用启动时，无论是否立即需要，所有模块都会被加载。对于大多数场景，这种方式并无问题，但在无服务器环境（serverless environment）或 worker 场景下，启动延迟（“冷启动”）尤为关键，此时急切加载可能成为瓶颈。

通过懒加载（Lazy Loading），只加载当前 serverless 函数调用所需的模块，可以显著缩短启动时间。此外，你还可以在 serverless 函数“预热”后，异步加载其他模块（即延迟注册），进一步加快后续调用的启动速度。

<CalloutInfo>
  如果你熟悉 **[Angular](https://angular.dev/)**
  框架，可能见过“[懒加载模块](https://angular.dev/guide/ngmodules/lazy-loading#lazy-loading-basics)”这个术语。请注意，这项技术在
  Nest 中的实现**与 Angular 完全不同**，只是命名类似，功能和机制并不相同。
</CalloutInfo>

<CalloutInfo type="warning">
  使用懒加载模块和服务时，[生命周期钩子方法](/fundamentals/lifecycle-events)不会被调用。
</CalloutInfo>

## 快速上手

要实现按需加载模块，Nest 提供了 `LazyModuleLoader` 类，你可以像常规依赖注入一样将其注入到类中：

```ts filename='cats.service.ts'
import { LazyModuleLoader } from '@nestjs/core'

@Injectable()
export class CatsService {
  constructor(private lazyModuleLoader: LazyModuleLoader) {}
}
```

另外，你也可以在应用的入口文件（`main.ts`）中获取 `LazyModuleLoader` 提供者的引用，如下所示：

```ts
// "app" 代表 Nest 应用实例
const lazyModuleLoader = app.get(LazyModuleLoader)
```

有了它之后，你可以通过如下方式加载任意模块：

```ts
const { LazyModule } = await import('./lazy.module')
const moduleRef = await this.lazyModuleLoader.load(() => LazyModule)
```

<CalloutInfo>
<div>
“懒加载”模块在首次通过 `LazyModuleLoader#load` 方法加载时会被缓存。这意味着，后续每次加载同一个模块都会非常快，并且直接返回缓存实例，而不会重复加载。
</div>

```bash
第 1 次加载 "LazyModule"
time: 2.379ms
第 2 次加载 "LazyModule"
time: 0.294ms
第 3 次加载 "LazyModule"
time: 0.303ms
```

<div className="mt-5">
  此外，“懒加载”模块会与应用启动时急切加载的模块，以及后续注册的其他懒加载模块共享同一个模块图。
</div>

</CalloutInfo>

`lazy.module.ts` 是一个导出 **标准 Nest 模块** 的 TypeScript 文件（无需额外更改）。

`LazyModuleLoader#load` 方法会返回[模块引用（module reference）](/fundamentals/module-ref)（即 `LazyModule` 的引用），你可以通过它访问内部的提供者列表，并通过注入令牌（Injection Token）获取任意提供者的实例。

例如，假设我们有如下定义的 `LazyModule`：

```ts
@Module({
  providers: [LazyService],
  exports: [LazyService],
})
export class LazyModule {}
```

<CalloutInfo>
  懒加载模块不能注册为**全局模块**，因为他们是按需注册的，在所有静态注册模块实例化后才会被加载。同理，注册为**全局增强器**（如守卫、拦截器等）的功能也无法正常工作。
</CalloutInfo>

这样，我们就可以获取 `LazyService` 提供者的实例：

```ts
const { LazyModule } = await import('./lazy.module')
const moduleRef = await this.lazyModuleLoader.load(() => LazyModule)

const { LazyService } = await import('./lazy.service')
const lazyService = moduleRef.get(LazyService)
```

<CalloutInfo type='warning'>
  如果你使用 Webpack，请确保在 `tsconfig.json` 文件中设置 `compilerOptions.module` 为 `"esnext"`，并添加 `compilerOptions.moduleResolution` 属性，值为 `"node"`：

```json
 {
   "compilerOptions": {
     "module": "esnext",
     "moduleResolution": "node",
     ...
   }
 }
```

配置好这些选项后，你就可以利用[代码分割（code splitting）](https://webpack.js.org/guides/code-splitting/) 功能。

</CalloutInfo>

## 懒加载控制器、网关和解析器

在 Nest 中，控制器或 GraphQL 应用中的解析器（Resolver）用于处理一组路由、路径、主题，或 GraphQL 查询与变更。你无法通过 `LazyModuleLoader` 类对他们进行懒加载。

<CalloutInfo type="warning">
  在懒加载模块中注册的控制器、[解析器](/graphql/resolvers) 和[网关](/websockets/gateways)
  都不会按预期工作。同样，无法按需注册中间件函数（即通过实现 `MiddlewareConsumer` 接口的中间件）。
</CalloutInfo>

例如，如果你在底层使用 Fastify 驱动（`@nestjs/platform-fastify` 包）构建 REST API（HTTP 应用），Fastify 不支持在应用启动并开始监听后动态注册路由。这意味着，即使我们分析了模块控制器中的路由映射，所有懒加载的路由在运行时也无法被访问，因为无法动态注册。

同理，`@nestjs/microservices` 包中的部分传输层（如 Kafka、gRPC 或 RabbitMQ）要求在连接建立前就完成主题或通道的订阅。一旦应用开始监听消息，框架将无法再订阅新的主题。

此外，`@nestjs/graphql` 包在启用 code first 方式时，会根据元数据动态生成 GraphQL schema。这要求所有相关类必须预先加载，否则无法生成有效的 schema。

## 常见使用场景

懒加载模块通常用于如下场景：worker、定时任务（cron job）、lambda & serverless 函数、webhook 等需要根据输入参数（如路由路径、日期、查询参数等）动态触发不同服务（业务逻辑）。对于启动时间要求不高的单体应用，懒加载模块的意义并不大。

# 执行上下文

Nest 提供了一套强大的工具类，旨在帮助开发者构建能够适配多种运行环境的通用程序，例如基于 Nest 的 HTTP 服务、微服务架构，或是 WebSocket 应用。这些工具类可以提取当前的执行上下文信息，使我们能够编写可在不同类型的控制器、处理器与运行平台之间灵活复用的守卫、异常过滤器和拦截器。

本章将重点介绍两个核心类：`ArgumentsHost` 和 `ExecutionContext`，它们是构建高度抽象和可扩展逻辑的关键基础。

## ArgumentsHost 类

`ArgumentsHost` 提供了一组方法，用于访问传递给处理器（handler）的原始参数。它抽象了不同上下文类型（如 HTTP、RPC 或 WebSocket）下的参数结构，并允许你以统一的方式提取相关数据。

在需要访问请求上下文的场景中，Nest 会自动注入 `ArgumentsHost` 实例，通常以 `host` 作为参数名称。例如，在[异常过滤器](/exception-filters#arguments-host)的 `catch()` 方法中，你会收到一个 `ArgumentsHost` 实例作为入参。

简而言之，`ArgumentsHost` 封装了对处理器参数的访问逻辑。例如：

- 在 HTTP 应用中（如使用 `@nestjs/platform-express）`，它封装了 Express 风格的参数数组 `[request, response, next]`。
- 在 GraphQL 应用中，它则封装了 GraphQL 专属参数结构 `[root, args, context, info]`。

这一机制使你可以在框架内部以一致的方式访问底层平台提供的原始参数，而无需关心其具体实现。

## 判断当前应用上下文类型

为了编写在多种环境中通用的逻辑组件（如守卫、异常过滤器、拦截器），我们通常需要判断当前的执行上下文类型。`ArgumentsHost` 提供的 `getType()` 方法正是用于实现这一目的：

```ts
import { GqlContextType } from '@nestjs/graphql'

if (host.getType() === 'http') {
  // 针对 HTTP（REST）请求的处理逻辑
} else if (host.getType() === 'rpc') {
  // 针对微服务（RPC）调用的处理逻辑
} else if (host.getType<GqlContextType>() === 'graphql') {
  // 针对 GraphQL 请求的处理逻辑
}
```

通过上下文类型判断机制，我们可以精确控制逻辑的适用范围，使组件在不同平台间具备良好的适应性与可维护性。

## 获取处理器参数

要获取传递给处理器的参数数组，可以使用 `host` 对象的 `getArgs()` 方法：

```ts
const [req, res, next] = host.getArgs()
```

如果只需访问某个特定参数，也可以通过 `getArgByIndex()` 方法按索引获取：

```ts
const request = host.getArgByIndex(0)
const response = host.getArgByIndex(1)
```

虽然通过索引访问参数是可行的，但这种方式会使代码强依赖于特定的执行上下文（如 HTTP、WebSocket 或 RPC），降低通用性与可维护性，因此并不推荐。

更推荐的方式是使用 `host` 提供的上下文切换方法，明确切换至当前处理器所处的上下文类型。这类方法包括：

```ts
switchToHttp(): HttpArgumentsHost   // 切换到 HTTP 上下文
switchToWs(): WsArgumentsHost       // 切换到 WebSocket 上下文
switchToRpc(): RpcArgumentsHost     // 切换到 RPC（微服务）上下文
```

不同的传输层（如 HTTP、WebSocket、RPC）中，`ArgumentsHost` 提供了对应的适配器接口，可用于获取上下文相关的请求数据和底层框架对象。例如，在 HTTP 场景下，可以调用 `switchToHttp()` 获取一个 `HttpArgumentsHost` 实例，从中提取 Express 的请求与响应对象：

```ts
const ctx = host.switchToHttp()
const request = ctx.getRequest<Request>()
const response = ctx.getResponse<Response>()
```

如果当前上下文为 WebSocket，可以通过 `switchToWs()` 获取 `WsArgumentsHost`，用于访问客户端连接对象与传入数据：

```ts
export interface WsArgumentsHost {
  /** 获取客户端传入的数据 */
  getData<T>(): T

  /** 获取客户端连接对象（如 Socket.IO 客户端） */
  getClient<T>(): T
}
```

在微服务（RPC）场景中，调用 `switchToRpc()` 将返回 RpcArgumentsHost，可用于访问消息内容与上下文：

```ts
export interface RpcArgumentsHost {
  /** 获取传入的数据对象 */
  getData<T>(): T

  /** 获取 RPC 上下文对象（如消息上下文） */
  getContext<T>(): T
}
```

<CalloutInfo>
  应根据所使用的传输机制（HTTP、WebSocket 或
  RPC）选择对应的上下文切换方法。每种上下文类型都提供了访问底层平台对象（如 Express、Socket.IO
  或自定义传输器）的能力，有助于提升代码的可读性与稳定性。
</CalloutInfo>

## ExecutionContext 类

`ExecutionContext` 继承自 `ArgumentsHost`，并在此基础上提供了更多关于当前执行流程的详细信息。与 `ArgumentsHost` 类似，Nest 会在需要的地方自动注入 `ExecutionContext` 实例，比如[守卫](/guards#execution-context)的 `canActivate()` 方法和[拦截器](/interceptors#execution-context)的 `intercept()` 方法。它提供了如下方法：

```ts
export interface ExecutionContext extends ArgumentsHost {
  /**
   * 返回当前处理器所属控制器类的类型。
   */
  getClass<T>(): Type<T>
  /**
   * 返回即将在请求管道中被调用的处理器（方法）引用。
   */
  getHandler(): Function
}
```

`getHandler()` 方法返回即将被调用的处理器方法引用。`getClass()` 方法返回该处理器所属的控制器类类型。例如，在 HTTP 场景下，如果当前处理的是绑定到 `CatsController` 的 `create()` 方法的 `POST` 请求，`getHandler()` 会返回 `create()` 方法的引用，`getClass()` 会返回 `CatsController` 类（注意是类而非实例）。

```ts
const methodKey = ctx.getHandler().name // "create"
const className = ctx.getClass().name // "CatsController"
```

能够同时访问当前类和处理器方法的引用极大提升了灵活性。更重要的是，这让我们可以在守卫或拦截器中访问通过 `Reflector#createDecorator` 或内置 `@SetMetadata()` 装饰器设置的元数据。相关用法将在下文介绍。

## 反射与元数据

Nest 支持通过 `Reflector#createDecorator` 方法自定义装饰器，或使用内置的 `@SetMetadata()` 装饰器，为路由处理器附加自定义元数据（Metadata）。本节将对比这两种方式，并演示如何在守卫或拦截器中访问这些元数据。

要使用 `Reflector#createDecorator` 创建强类型装饰器，需要指定类型参数。例如，下面创建了一个接收字符串数组参数的 `Roles` 装饰器：

```ts filename='roles.decorator.ts'
import { Reflector } from '@nestjs/core'

export const Roles = Reflector.createDecorator<string[]>()
```

此时，`Roles` 装饰器是一个接收 `string[]` 类型参数的函数。

现在，我们可以直接在处理器上使用该装饰器：

```ts filename='cats.controller.ts'
@Post()
@Roles(['admin'])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

如上，我们将 `Roles` 装饰器的元数据附加到了 `create()` 方法上，表示只有拥有 `admin` 角色的用户才能访问该路由。

要访问路由的角色（自定义元数据），可以通过 `Reflector` 辅助类实现。`Reflector` 可像普通服务一样注入到类中：

```ts filename='roles.guard.ts'
import { Reflector } from '@nestjs/core'

@Injectable()
export class RolesGuard {
  constructor(private reflector: Reflector) {}
}
```

接下来，可以通过 `get()` 方法读取处理器上的元数据：

```ts
const roles = this.reflector.get(Roles, context.getHandler())
```

`Reflector#get` 方法允许我们通过传入两个参数（装饰器引用和上下文对象）来获取元数据。在本例中，第一个参数是 `Roles` 装饰器（见上文 `roles.decorator.ts`），第二个参数是 `context.getHandler()`，即当前处理的路由处理器函数。

此外，也可以在控制器类上应用元数据，使其作用于该控制器下的所有路由：

```ts filename='cats.controller.ts'
@Roles(['admin'])
@Controller('cats')
export class CatsController {}
```

此时，如需提取控制器上的元数据，只需将 `context.getClass()` 作为第二个参数传递（即以控制器类作为元数据提取的上下文），而不是 `context.getHandler()`：

```ts filename='roles.guard.ts'
const roles = this.reflector.get(Roles, context.getClass())
```

由于可以在多个层级（如控制器和方法）上设置元数据，有时我们需要同时提取并合并多个上下文的元数据。`Reflector` 类为此提供了两个实用方法，可以一次性提取控制器和方法上的元数据，并以不同方式进行合并。

来看一个同时在控制器和方法上都设置了 `Roles` 元数据的场景：

```ts filename='cats.controller.ts'
@Roles(['user'])
@Controller('cats')
export class CatsController {
  @Post()
  @Roles(['admin'])
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto)
  }
}
```

如果你的意图是将 `'user'` 作为默认角色，并在某些方法上进行覆盖，可以使用 `getAllAndOverride()` 方法：

```ts
const roles = this.reflector.getAllAndOverride(Roles, [context.getHandler(), context.getClass()])
```

在上述代码中，守卫运行在 `create()` 方法上下文时，`roles` 的值将为 `['admin']`。

如果你希望将多个层级的元数据合并（该方法会合并数组和对象），可以使用 `getAllAndMerge()` 方法：

```ts
const roles = this.reflector.getAllAndMerge(Roles, [context.getHandler(), context.getClass()])
```

此时，`roles` 的值将为 `['user', 'admin']`。

这两个合并方法的第一个参数为元数据键，第二个参数为元数据目标上下文数组（即 `getHandler()` 和/或 `getClass()` 的调用结果）。

## 底层实现方式（Low-level approach）

如前所述，除了使用 `Reflector#createDecorator`，你还可以用内置的 `@SetMetadata()` 装饰器为处理器附加元数据。

```ts filename='cats.controller.ts'
import { SetMetadata } from '@nestjs/common'

@Post()
@SetMetadata('roles', ['admin'])
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

如上，我们将 `roles` 元数据（`roles` 为元数据键，`['admin']` 为对应值）附加到了 `create()` 方法上。虽然这样做可以实现功能，但并不推荐直接在路由中使用 `@SetMetadata()`。更好的做法是自定义装饰器，如下所示：

```ts filename='roles.decorator.ts'
import { SetMetadata } from '@nestjs/common'

export const Roles = (...roles: string[]) => SetMetadata('roles', roles)
```

这种方式更简洁、可读性更高，也更接近 `Reflector#createDecorator` 的用法。不同之处在于，`@SetMetadata` 允许你完全控制元数据的键和值，并且可以创建接收多个参数的装饰器。

有了自定义的 `@Roles()` 装饰器后，我们就可以用它来装饰 `create()` 方法：

```ts filename='cats.controller.ts'
@Post()
@Roles('admin')
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

要访问路由的角色（自定义元数据），依然可以使用 `Reflector` 辅助类：

```ts filename='roles.guard.ts'
import { Reflector } from '@nestjs/core'

@Injectable()
export class RolesGuard {
  constructor(private reflector: Reflector) {}
}
```

此时，读取处理器元数据的方法如下：

```ts
const roles = this.reflector.get<string[]>('roles', context.getHandler())
```

这里我们传入元数据键（本例为 `'roles'`）作为第一个参数，其他用法与 `Reflector#createDecorator` 示例一致。

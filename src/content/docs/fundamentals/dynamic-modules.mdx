# 动态模块

[模块章节](/modules)介绍了 Nest 模块的基础知识，并简要提及了[动态模块](/modules#dynamic-modules#动态模块配置)。本章将深入解析动态模块，帮助你全面理解其概念、使用场景及实现方式。

## 简介

在文档的概览部分，大多数示例代码采用了常规的静态模块（Static Module）方式。模块用于组织一组组件，如[提供者](/providers)和[控制器](/controllers)，他们作为应用的模块化单元协同工作。模块为这些组件提供执行上下文或作用域。例如，在模块中定义的提供者对该模块的其他成员可见，无需导出即可直接访问。若需让某个提供者在模块外部可用，需先从其宿主模块导出，并在消费模块中导入。

下面通过一个常见示例进行说明。

首先，定义一个 `UsersModule`，用于提供并导出 `UsersService`。`UsersModule` 是 `UsersService` 的**宿主模块**：

```ts
import { Module } from '@nestjs/common'
import { UsersService } from './users.service'

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

接着，定义一个 `AuthModule`，它导入了 `UsersModule`，从而可以在内部使用 `UsersModule` 导出的提供者：

```ts
import { Module } from '@nestjs/common'
import { AuthService } from './auth.service'
import { UsersModule } from '../users/users.module'

@Module({
  imports: [UsersModule],
  providers: [AuthService],
  exports: [AuthService],
})
export class AuthModule {}
```

通过上述结构，可以在 `AuthModule` 的 `AuthService` 中注入 `UsersService`：

```ts
import { Injectable } from '@nestjs/common'
import { UsersService } from '../users/users.service'

@Injectable()
export class AuthService {
  constructor(private usersService: UsersService) {}
  /*
    实现细节，使用 this.usersService
  */
}
```

这种方式称为**静态模块绑定**。Nest 需要在宿主模块和消费模块中声明所有模块组装信息。下面拆解该过程的具体步骤。Nest 通过以下流程使 `UsersService` 能在 `AuthModule` 内部使用：

1. 实例化 `UsersModule`，递归导入其依赖的其他模块，并解析所有依赖（详见[自定义提供者](/fundamentals/custom-providers)）。
2. 实例化 `AuthModule`，并将 `UsersModule` 导出的提供者注入到 `AuthModule` 的组件中（如同这些提供者直接在 `AuthModule` 中声明一样）。
3. 在 `AuthService` 中注入 `UsersService` 实例。

## 动态模块的使用场景

使用静态模块绑定时，消费模块无法影响宿主模块中提供者的配置方式。这一点为何重要？设想这样一种场景：我们有一个通用模块，需要在不同环境下展现不同行为。这类似于许多系统中的“插件”机制，即通用功能在被消费前需要进行配置。

以 Nest 的**配置模块（Configuration Module）**为例。许多应用希望通过配置模块将配置信息外部化，从而能够根据不同部署环境动态调整应用设置，例如开发环境使用开发数据库，测试环境使用测试数据库等。通过将配置参数的管理交给配置模块，应用源码即可与配置解耦。

然而，配置模块本身是通用的（类似“插件”），需要由消费模块进行定制。这时就需要用到动态模块。利用动态模块特性，我们可以让配置模块变为动态，使消费模块在导入时通过 API 灵活定制其行为。

换句话说，动态模块为模块间的导入提供了 API，允许在导入时自定义模块的属性和行为，而不像静态绑定那样固定不变。

## 配置模块示例

本节将使用[配置章节](/techniques/configuration)中的基础示例代码，完整代码可在[此处](https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules)获取。

我们的需求是让 `ConfigModule` 能接受一个 `options` 对象进行定制。基础示例中 `.env` 文件的位置是写死在项目根目录下。假设我们希望这个位置可配置，比如将所有 `.env` 文件放在项目根目录下的 `config` 文件夹（与 `src` 同级）。这样，在不同项目中使用 `ConfigModule` 时就可以灵活选择不同的文件夹。

动态模块允许我们在导入模块时传递参数，从而改变其行为。我们先从消费模块的视角出发，倒推实现方式。首先，回顾下静态导入 `ConfigModule` 的例子（即无法影响被导入模块行为的方式）。请注意 `@Module()` 装饰器中的 `imports` 数组：

```ts
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { ConfigModule } from './config/config.module'

@Module({
  imports: [ConfigModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

再来看下**动态模块**导入的方式，此时我们传递了一个配置对象。对比这两种方式在 `imports` 数组上的区别：

```ts
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { ConfigModule } from './config/config.module'

@Module({
  imports: [ConfigModule.register({ folder: './config' })],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

来看下上面动态模块示例发生了什么：

1. `ConfigModule` 是一个普通类，因此我们可以推断它有一个**静态方法** `register()`。之所以是静态方法，是因为我们通过类名调用，而不是实例。注意：方法名可以自定义，但通常建议用 `forRoot()` 或 `register()`。
2. `register()` 方法由我们自行定义，可以接受任意参数。这里我们用一个简单的 `options` 对象。
3. 可以推断 `register()` 方法必须返回类似模块的对象，因为它的返回值出现在 `imports` 列表中，而该列表通常只包含模块类名。

实际上，`register()` 方法返回的是一个**动态模块（Dynamic Module）**。动态模块是在运行时创建的模块，拥有与静态模块完全相同的属性，只是多了一个 `module` 属性。我们先回顾下静态模块声明，关注传递给装饰器的模块选项：

```ts
@Module({
  imports: [DogsModule],
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
```

动态模块返回的对象接口与上面完全一致，只是多了一个 `module` 属性。`module` 属性用于指定模块名，通常与类名一致，如下例所示。

<CalloutInfo>
  <div>对于动态模块，模块选项对象中，除了 `module` 属性外，其他属性都是可选的。</div>
</CalloutInfo>

那么静态的 `register()` 方法到底做了什么？它的职责就是返回一个符合 `DynamicModule` 接口的对象。调用它时，实际上就是为 `imports` 列表提供了一个模块，就像静态方式直接写模块类名一样。也就是说，动态模块 API 只是返回一个模块，只不过这些属性是通过代码动态指定的，而不是写死在 `@Module` 装饰器里。

还有几点细节需要补充：

1. 现在我们可以明确，`@Module()` 装饰器的 `imports` 属性不仅可以接受模块类名（如 `imports: [UsersModule]`），还可以接受返回动态模块的函数（如 `imports: [ConfigModule.register(...)]`）。
2. 动态模块本身也可以导入其他模块。虽然本例未用到，但如果动态模块依赖其他模块的提供者，可以通过 `imports` 属性导入，方式与静态模块完全一致。

理解了这些，我们来看下动态 `ConfigModule` 的声明应该是什么样子。

```ts
import { DynamicModule, Module } from '@nestjs/common'
import { ConfigService } from './config.service'

@Module({})
export class ConfigModule {
  static register(): DynamicModule {
    return {
      module: ConfigModule,
      providers: [ConfigService],
      exports: [ConfigService],
    }
  }
}
```

现在应该能看出各部分如何协同工作了。调用 `ConfigModule.register(...)` 会返回一个 `DynamicModule` 对象，其属性本质上与之前通过 `@Module` 装饰器声明的静态模块一致。

<CalloutInfo>
  <div>记得从 `@nestjs/common` 导入 `DynamicModule`。</div>
</CalloutInfo>

不过目前我们的动态模块还未实现可配置的能力。接下来我们将实现这一功能。

## 模块配置

要定制 `ConfigModule` 的行为，最直接的方式是在静态的 `register()` 方法中传入 `options` 对象。来看下消费模块的 `imports` 属性：

```ts
import { Module } from '@nestjs/common'
import { AppController } from './app.controller'
import { AppService } from './app.service'
import { ConfigModule } from './config/config.module'

@Module({
  imports: [ConfigModule.register({ folder: './config' })],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

这样，`options` 对象就会传递给动态模块。那么，如何在 `ConfigModule` 内部使用这个 `options` 呢？实际上，`ConfigModule` 主要用于提供并导出一个可注入的服务 —— `ConfigService`。真正需要用到 `options` 的是 `ConfigService`。假设我们已经能够将 `register()` 里的 `options` 传递给 `ConfigService`，就可以根据 `options` 的属性灵活定制服务行为。（注意：目前参数传递尚未实现，这里暂时将 `options` 写死，后续会完善。）

```ts
import { Injectable } from '@nestjs/common'
import * as dotenv from 'dotenv'
import * as fs from 'fs'
import * as path from 'path'
import { EnvConfig } from './interfaces'

@Injectable()
export class ConfigService {
  private readonly envConfig: EnvConfig

  constructor() {
    const options = { folder: './config' }

    const filePath = `${process.env.NODE_ENV || 'development'}.env`
    const envFile = path.resolve(__dirname, '../../', options.folder, filePath)
    this.envConfig = dotenv.parse(fs.readFileSync(envFile))
  }

  get(key: string): string {
    return this.envConfig[key]
  }
}
```

现在，`ConfigService` 已经可以根据 `options` 指定的文件夹查找 `.env` 文件。

接下来，我们需要将 `register()` 传入的 `options` 注入到 `ConfigService`。这一步将通过依赖注入机制实现。请务必理解这一点：`ConfigModule` 提供了 `ConfigService`，而 `ConfigService` 依赖于运行时传入的 `options` 对象。因此，我们需要先将 `options` 绑定到 Nest IoC 容器，再让 Nest 注入到 `ConfigService`。回忆一下[自定义提供者章节](/fundamentals/custom-providers#non-service-based-providers)提到，提供者不仅可以是服务，也可以是任意值，因此通过依赖注入处理简单对象完全可行。

我们可以在静态的 `register()` 方法中，将 `options` 作为提供者绑定到 IoC 容器。只需将 `options` 定义为一个提供者，这样就能在 `ConfigService` 中注入使用。请看 `providers` 数组的写法：

```ts
import { DynamicModule, Module } from '@nestjs/common'
import { ConfigService } from './config.service'

@Module({})
export class ConfigModule {
  static register(options: Record<string, any>): DynamicModule {
    return {
      module: ConfigModule,
      providers: [
        {
          provide: 'CONFIG_OPTIONS',
          useValue: options,
        },
        ConfigService,
      ],
      exports: [ConfigService],
    }
  }
}
```

最后一步，就是在 `ConfigService` 中注入 `'CONFIG_OPTIONS'` 提供者。注意，使用非类 token 时，需要用 `@Inject()` 装饰器（详见[自定义提供者章节](/fundamentals/custom-providers#non-class-based-provider-tokens)）。

```ts
import * as dotenv from 'dotenv'
import * as fs from 'fs'
import * as path from 'path'
import { Injectable, Inject } from '@nestjs/common'
import { EnvConfig } from './interfaces'

@Injectable()
export class ConfigService {
  private readonly envConfig: EnvConfig

  constructor(@Inject('CONFIG_OPTIONS') private options: Record<string, any>) {
    const filePath = `${process.env.NODE_ENV || 'development'}.env`
    const envFile = path.resolve(__dirname, '../../', options.folder, filePath)
    this.envConfig = dotenv.parse(fs.readFileSync(envFile))
  }

  get(key: string): string {
    return this.envConfig[key]
  }
}
```

补充说明：上面为了简化，直接使用了字符串 `'CONFIG_OPTIONS'` 作为注入令牌。最佳实践是将其定义为常量（或 `Symbol`），并单独放在一个文件中，然后导入使用。例如：

```ts
export const CONFIG_OPTIONS = 'CONFIG_OPTIONS'
```

## 示例

本章完整代码可在[此处](https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules)查看。

## 社区命名规范

你可能注意到，部分 `@nestjs/` 包中常见 `forRoot`、`register`、`forFeature` 等方法。虽然没有强制要求，但官方通常遵循以下约定：

- `register` 用于为每个调用模块单独配置动态模块。例如，Nest 的 `@nestjs/axios`：`HttpModule.register({ baseUrl: 'someUrl' })`。如果在另一个模块中调用 `HttpModule.register({ baseUrl: 'somewhere else' })`，则会生成不同的配置。你可以为任意多个模块分别注册。

- `forRoot` 用于全局配置动态模块，通常只需调用一次，并在多个地方复用该配置（即使你未直接感知，因为已被抽象）。因此，像 `GraphQLModule.forRoot()`、`TypeOrmModule.forRoot()` 这类方法一般只调用一次。

- `forFeature` 用于在复用 `forRoot` 配置的基础上，为特定模块做进一步定制（如指定可访问的仓库、日志上下文等）。

这些方法通常还提供异步版本，如 `registerAsync`、`forRootAsync`、`forFeatureAsync`，其作用类似，只是配置方式支持 Nest 的依赖注入。

## 可配置模块构建器（ConfigurableModuleBuilder）

手动实现高度可配置、支持异步方法（如 `registerAsync`、`forRootAsync` 等）的动态模块，对新手来说较为复杂。为此，Nest 提供了 `ConfigurableModuleBuilder`，可帮助你用极少代码快速构建模块“蓝图”。

以 `ConfigModule` 为例，使用 `ConfigurableModuleBuilder` 重写：首先，定义一个接口，描述 `ConfigModule` 所需的选项：

```ts
export interface ConfigModuleOptions {
  folder: string
}
```

然后，在 `config.module.ts` 同级目录下新建 `config.module-definition.ts`，利用 `ConfigurableModuleBuilder` 构建模块定义：

```ts filename='config.module-definition.ts'
import { ConfigurableModuleBuilder } from '@nestjs/common'
import { ConfigModuleOptions } from './interfaces/config-module-options.interface'

export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<ConfigModuleOptions>().build()
```

接下来，修改 `config.module.ts`，让其继承自动生成的 `ConfigurableModuleClass`：

```ts
import { Module } from '@nestjs/common'
import { ConfigService } from './config.service'
import { ConfigurableModuleClass } from './config.module-definition'

@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class ConfigModule extends ConfigurableModuleClass {}
```

将 `ConfigurableModuleClass` 作为父类扩展后，`ConfigModule` 不仅具备自定义实现的 `register` 方法，还自动拥有 `registerAsync` 方法。这样，使用者即可通过异步工厂等方式异步配置该模块：

```ts
@Module({
  imports: [
    ConfigModule.register({ folder: './config' }),
    // 或：
    // ConfigModule.registerAsync({
    //   useFactory: () => ({
    //     folder: './config',
    //   }),
    //   inject: [...其他依赖...]
    // }),
  ],
})
export class AppModule {}
```

`registerAsync` 方法接收如下对象作为参数：

```typescript
{
  /**
   * 注入令牌，指向将被实例化为提供者的类。
   * 该类必须实现对应的接口。
   */
  useClass?: Type<
    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
  >;
  /**
   * 返回配置对象（或返回配置对象的 Promise ）的工厂函数，用于配置模块。
   */
  useFactory?: (...args: any[]) => Promise<ModuleOptions> | ModuleOptions;
  /**
   * 工厂函数可注入的依赖项。
   */
  inject?: FactoryProvider['inject'];
  /**
   * 注入令牌，指向已存在的提供者。该提供者必须实现对应的接口。
   */
  useExisting?: Type<
    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
  >;
}
```

下面依次介绍上述各个属性的作用：

- `useFactory`：用于返回配置对象的工厂函数，可以是同步或异步函数。如果需要在工厂函数中注入依赖，请使用 `inject` 属性。上面的示例中就采用了这种方式。
- `inject`：用于指定注入到工厂函数中的依赖项数组。依赖项的顺序必须与工厂函数参数的顺序一致。
- `useClass`：指定一个类作为提供者，Nest 会实例化该类。该类必须实现相应的接口，通常需要提供一个 `create()` 方法用于返回配置对象。详细说明可参考下方[自定义方法名](/fundamentals/dynamic-modules#custom-method-key)小节。
- `useExisting`：`useClass` 的变体，允许你复用已注册的现有提供者，而不是让 Nest 新建一个类实例。当你希望使用模块中已存在的提供者时非常有用。需要注意，该类必须实现与 `useClass` 相同的接口（即需要提供 `create()` 方法，除非你自定义了方法名，详见下方[自定义方法名](/fundamentals/dynamic-modules#custom-method-key)小节）。

以上三种方式（`useFactory`、`useClass`、`useExisting`）互斥，请根据实际需求选择其中一种即可。

最后，更新 `ConfigService`，注入自动生成的模块选项提供者，而非原先的 `'CONFIG_OPTIONS'`：

```ts
@Injectable()
export class ConfigService {
  constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions) { ... }
}
```

## 自定义方法名

`ConfigurableModuleClass` 默认提供 `register` 及其异步版本 `registerAsync` 方法。如果需要自定义方法名，可以通过 `ConfigurableModuleBuilder#setClassMethodName` 实现：

```ts filename='config.module-definition.ts'
export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<ConfigModuleOptions>().setClassMethodName('forRoot').build()
```

这样会生成带有 `forRoot` 和 `forRootAsync` 方法的类。例如：

```ts
@Module({
  imports: [
    ConfigModule.forRoot({ folder: './config' }), // 注意这里使用的是 "forRoot"
    // 或者：
    // ConfigModule.forRootAsync({
    //   useFactory: () => ({
    //     folder: './config',
    //   }),
    //   inject: [...其他依赖...]
    // }),
  ],
})
export class AppModule {}
```

## 自定义选项工厂类

`registerAsync`（或 `forRootAsync`，具体取决于配置）方法允许用户通过提供者定义来生成模块配置。因此，库的使用者可以自定义一个类用于构建配置对象。

```ts
@Module({
  imports: [
    ConfigModule.registerAsync({
      useClass: ConfigModuleOptionsFactory,
    }),
  ],
})
export class AppModule {}
```

默认情况下，该类需要实现一个 `create()` 方法，用于返回模块的配置对象。如果你的库采用了不同的命名规范，可以通过 `ConfigurableModuleBuilder#setFactoryMethodName` 自定义工厂方法名，例如 `createConfigOptions`：

```ts filename='config.module-definition.ts'
export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<ConfigModuleOptions>()
    .setFactoryMethodName('createConfigOptions')
    .build()
```

此时，`ConfigModuleOptionsFactory` 类必须实现 `createConfigOptions` 方法（而不是 `create`）：

```ts
@Module({
  imports: [
    ConfigModule.registerAsync({
      useClass: ConfigModuleOptionsFactory, // 该类必须实现 "createConfigOptions" 方法
    }),
  ],
})
export class AppModule {}
```

## 额外选项

在某些场景下，模块可能需要通过额外选项来控制其行为（如 `isGlobal` 标志，或称为 `global`）。这些选项通常不应包含在 `MODULE_OPTIONS_TOKEN` 提供者中，因为他们与模块内部注册的服务或提供者（如 `ConfigService`）无关。例如，`ConfigService` 并不需要知道其宿主模块是否为全局模块。

此时，可以使用 `ConfigurableModuleBuilder#setExtras` 方法。示例代码如下：

```ts
export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<ConfigModuleOptions>()
    .setExtras(
      {
        isGlobal: true,
      },
      (definition, extras) => ({
        ...definition,
        global: extras.isGlobal,
      })
    )
    .build()
```

上述示例中，`setExtras` 方法的第一个参数用于指定“额外”属性的默认值。第二个参数是一个函数，接收自动生成的模块定义（包含 `provider`、`exports` 等）和 `extras` 对象（代表额外属性，可能由使用者指定或采用默认值），并返回修改后的模块定义。在本例中，我们将 `extras.isGlobal` 赋值给模块定义的 `global` 属性（该属性决定模块是否为全局模块，详见[此处](/modules#dynamic-modules)）。

在使用该模块时，可以如下方式传递额外的 `isGlobal` 标志：

```ts
@Module({
  imports: [
    ConfigModule.register({
      isGlobal: true,
      folder: './config',
    }),
  ],
})
export class AppModule {}
```

需要注意的是，由于 `isGlobal` 被声明为“额外”属性，它不会出现在 `MODULE_OPTIONS_TOKEN` 提供者中：

```ts
@Injectable()
export class ConfigService {
  constructor(@Inject(MODULE_OPTIONS_TOKEN) private options: ConfigModuleOptions) {
    // "options" 对象中不会包含 "isGlobal" 属性
    // ...
  }
}
```

## 扩展自动生成的方法

如有需要，可以扩展自动生成的静态方法（如 `register`、`registerAsync`）：

```ts
import { Module } from '@nestjs/common'
import { ConfigService } from './config.service'
import {
  ConfigurableModuleClass,
  ASYNC_OPTIONS_TYPE,
  OPTIONS_TYPE,
} from './config.module-definition'

@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class ConfigModule extends ConfigurableModuleClass {
  static register(options: typeof OPTIONS_TYPE): DynamicModule {
    return {
      // 你的自定义逻辑
      ...super.register(options),
    }
  }

  static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {
    return {
      // 你的自定义逻辑
      ...super.registerAsync(options),
    }
  }
}
```

请确保从模块定义文件中导出 `OPTIONS_TYPE` 和 `ASYNC_OPTIONS_TYPE` 类型：

```ts
export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN, OPTIONS_TYPE, ASYNC_OPTIONS_TYPE } =
  new ConfigurableModuleBuilder<ConfigModuleOptions>().build()
```

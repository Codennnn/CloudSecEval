# 测试

在现代软件开发中，自动化测试已成为保障代码质量与系统稳定性的核心环节。借助自动化手段，开发者可以在开发过程中便捷地重复执行单个测试或完整的测试套件，以持续验证功能正确性、性能达标情况以及系统集成效果。这不仅提高了测试覆盖率，也带来了更快速的反馈循环，进而提升开发效率和团队协作质量，尤其适用于代码提交、功能集成和版本发布等关键阶段。

常见的自动化测试类型包括：

- **单元测试（Unit Testing）**：验证单个功能模块的行为；
- **集成测试（Integration Testing）**：测试多个模块协作时的正确性；
- **端到端测试（End-to-End Testing, e2e）**：模拟用户行为以验证整个系统流程。

尽管自动化测试的好处显而易见，但测试环境的搭建往往让人望而却步。为了降低这一门槛，Nest 深度融合了现代测试理念，致力于打造高效、易用的测试体验。其内置的测试机制可助力开发者和团队快速上手，构建可靠的自动化测试流程。Nest 的测试支持具备以下特点：
• 自动为组件生成默认的单元测试文件，并提供应用级端到端测试的基础脚手架；
• 默认集成测试运行器，可用于构建隔离的模块实例或加载完整应用；
• 开箱即用地支持 [Jest](https://github.com/facebook/jest) 和 [Supertest](https://github.com/visionmedia/supertest)，但并不强绑定特定工具，保持框架的测试工具无关性；
• 测试环境中同样可用 Nest 的依赖注入系统，便于替换、模拟（mock）或注入测试专用的依赖项。

如上所述，Nest 不会限制你使用特定测试框架。你可以根据需求自由替换测试运行器或断言库，而无需放弃 Nest 提供的测试便利性和结构支持。

## 安装依赖

首先，安装 Nest 提供的测试模块：

```bash
$ npm install -D @nestjs/testing
```

## 单元测试

本示例将演示如何为两个类编写基础的单元测试：`CatsController` 和 `CatsService`。

如前所述，Nest 默认集成了 Jest 作为测试框架。Jest 不仅是测试运行器，还内置了断言方法和测试替身工具（Test Doubles），支持模拟（Mocking）、监视（Spying）等常见测试需求。

在本示例中，我们将手动实例化控制器与服务类，并验证它们是否按照既定的 API 行为正常工作。

```ts filename='cats.controller.spec.ts'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'

describe('CatsController', () => {
  let catsController: CatsController
  let catsService: CatsService

  beforeEach(() => {
    catsService = new CatsService()
    catsController = new CatsController(catsService)
  })

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const result = ['test']
      jest.spyOn(catsService, 'findAll').mockImplementation(() => result)

      expect(await catsController.findAll()).toBe(result)
    })
  })
})
```

<CalloutInfo>
  建议将测试文件放置在对应被测试文件的附近，并以 `.spec.ts` 或 `.test.ts`
  结尾，以便框架自动识别和运行。
</CalloutInfo>

需要注意的是，这个例子并未用到任何 Nest 的特有功能。我们并没有通过依赖注入来管理服务实例，而是手动将 `CatsService` 传入控制器。这种测试方式通常被称为**隔离测试**（Isolated Testing），其重点是测试类本身的逻辑行为，而不依赖于框架提供的上下文机制。

接下来我们将探索更具代表性的测试方式，展示如何借助 Nest 的能力进行更完整、框架融合度更高的测试。

## 测试工具

Nest 官方提供的 `@nestjs/testing` 包，内置了一套用于构建健壮测试流程的实用工具。我们可以借助其中的 Test 类来更优雅地重构前面的测试示例：

```ts filename='cats.controller.spec.ts'
import { Test } from '@nestjs/testing'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'

describe('CatsController', () => {
  let catsController: CatsController
  let catsService: CatsService

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      controllers: [CatsController],
      providers: [CatsService],
    }).compile()

    catsService = moduleRef.get(CatsService)
    catsController = moduleRef.get(CatsController)
  })

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const result = ['test']
      jest.spyOn(catsService, 'findAll').mockImplementation(() => result)

      expect(await catsController.findAll()).toBe(result)
    })
  })
})
```

Test 类提供了一个模拟的执行上下文，基本还原了 Nest 应用的运行环境，使你能够在测试中方便地管理实例、进行模拟（mock）或覆盖（override）。其中的 `createTestingModule()` 方法接收一份模块元数据配置（格式与 `@Module()` 装饰器相同），并返回一个 `TestingModule` 实例。

这个测试模块支持一系列便捷方法，最关键的是异步的 `compile()` 方法。它会初始化模块及其依赖关系（类似于生产环境中通过 `NestFactory.create()` 启动应用），并返回可供测试使用的模块引用。

<CalloutInfo>
  `compile()` 是一个异步方法，因此使用时必须加上 `await`。编译完成后，可通过
  `get()` 方法获取模块中声明的任何控制器或提供者实例。
</CalloutInfo>

`TestingModule` 继承自 `ModuleRef`，因此同样支持作用域提供者的动态解析。你可以使用 `resolve()` 方法来获取**作用域提供者**（如瞬态或请求作用域）的实例。而 get() 方法仅适用于获取静态单例。

```ts
const moduleRef = await Test.createTestingModule({
  controllers: [CatsController],
  providers: [CatsService],
}).compile()

catsService = await moduleRef.resolve(CatsService)
```

<CalloutInfo type="warning">
  使用 `resolve()`
  获取的实例来自于当前依赖注入子树的上下文，每次调用都对应唯一的上下文标识符。因此多次调用返回的实例可能不相等。
</CalloutInfo>

<CalloutInfo>
  想了解更多关于模块引用和作用域实例管理的内容，请参阅[模块引用（ModuleRef）章节](/fundamentals/module-ref)。
</CalloutInfo>

除了使用生产环境中的真实提供者外，测试时你还可以**覆盖**（override）它们，以注入[自定义提供者](/fundamentals/custom-providers)。这在需要替换数据库连接等外部依赖为 mock 实现时尤其有用。我们将在下一节详细介绍如何进行提供者覆盖，该机制在单元测试中同样适用。

## 自动模拟

在编写单元测试时，Nest 提供了一种便捷机制：**自动模拟依赖**。你可以通过定义一个**模拟工厂函数**（mock factory），让 Nest 自动为测试模块中尚未提供的依赖项生成模拟对象（Mock）。当某个类依赖较多、手动逐一编写 Mock 十分繁琐时，这一功能尤为高效实用。

启用该功能的方式是在 `createTestingModule()` 后链式调用 `.useMocker()` 方法，并传入一个用于创建模拟对象的工厂函数。该函数可以接收一个可选参数 token，代表待模拟的提供者令牌（如类、字符串、Symbol 等），并返回该依赖的模拟实现。

下面的示例展示了如何结合 [`jest-mock`](https://www.npmjs.com/package/jest-mock) 创建一个通用模拟器，以及如何使用 `jest.fn()` 为 `CatsService` 提供特定的模拟实现：

```ts
import { ModuleMocker, MockFunctionMetadata } from 'jest-mock'

const moduleMocker = new ModuleMocker(global)

describe('CatsController', () => {
  let controller: CatsController

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      controllers: [CatsController],
    })
      .useMocker((token) => {
        const results = ['test1', 'test2']

        if (token === CatsService) {
          return { findAll: jest.fn().mockResolvedValue(results) }
        }

        if (typeof token === 'function') {
          const mockMetadata = moduleMocker.getMetadata(
            token
          ) as MockFunctionMetadata<any, any>
          const Mock = moduleMocker.generateFromMetadata(mockMetadata)
          return new Mock()
        }
      })
      .compile()

    controller = moduleRef.get(CatsController)
  })
})
```

你还可以像获取普通提供者一样，从测试模块中检索自动生成的模拟对象，例如：`moduleRef.get(CatsService)`。

<CalloutInfo>
  你也可以直接传入一个通用模拟工厂函数，例如来自
  [`@golevelup/ts-jest`](https://github.com/golevelup/nestjs/tree/master/packages/testing)
  的 `createMock()` 方法。
</CalloutInfo>

<CalloutInfo type="warning">
  `REQUEST` 和 `INQUIRER`
  是框架内部的上下文绑定提供者，**无法被自动模拟**。如需在测试中替换它们，可通过自定义提供者或调用
  `.overrideProvider()` 方法进行显式覆盖。
</CalloutInfo>

## 端到端测试

与专注于单个模块或类的**单元测试**不同，**端到端测试**（e2e 测试）关注的是系统中各模块、类之间的高层级协作。它更贴近最终用户与实际系统交互的方式，因而在评估应用整体行为时具有重要价值。

随着项目规模增长，手动验证每一个 API 接口的响应变得越来越不现实。通过自动化的端到端测试，我们可以系统性地验证应用行为是否符合预期，确保在持续迭代中依然满足业务需求。

Nest 提供了类似单元测试的配置方式来书写 e2e 测试，并支持轻松集成 Supertest 库，用于模拟 HTTP 请求。

### 示例：使用 Supertest 编写 e2e 测试

```ts filename='cats.e2e-spec.ts'
import * as request from 'supertest'
import { Test } from '@nestjs/testing'
import { CatsModule } from '../../src/cats/cats.module'
import { CatsService } from '../../src/cats/cats.service'
import { INestApplication } from '@nestjs/common'

describe('Cats', () => {
  let app: INestApplication
  let catsService = { findAll: () => ['test'] }

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [CatsModule],
    })
      .overrideProvider(CatsService)
      .useValue(catsService)
      .compile()

    app = moduleRef.createNestApplication()
    await app.init()
  })

  it(`/GET cats`, () => {
    return request(app.getHttpServer()).get('/cats').expect(200).expect({
      data: catsService.findAll(),
    })
  })

  afterAll(async () => {
    await app.close()
  })
})
```

<CalloutInfo>
 如果你使用 [Fastify](/techniques/performance) 作为 HTTP 平台适配器，初始化方式略有不同。Fastify 本身内置了注入式测试能力，可直接用于 e2e 测试：

```ts filename='cats.e2e-spec.ts'
let app: NestFastifyApplication

beforeAll(async () => {
  app = moduleRef.createNestApplication<NestFastifyApplication>(
    new FastifyAdapter()
  )

  await app.init()
  await app.getHttpAdapter().getInstance().ready()
})

it(`/GET cats`, () => {
  return app
    .inject({
      method: 'GET',
      url: '/cats',
    })
    .then((result) => {
      expect(result.statusCode).toEqual(200)
      expect(result.payload).toEqual(/* expectedPayload */)
    })
})

afterAll(async () => {
  await app.close()
})
```

</CalloutInfo>

### 示例详解

本例扩展了前文介绍的测试思路。我们通过 `createNestApplication()` 创建并初始化一个完整的 Nest 应用实例，用于承载真实的模块加载、依赖注入与请求处理流程。

需要特别注意的是，当你仅调用 `compile()` 而未创建应用实例时，`HttpAdapterHost#httpAdapter` 仍未定义。因为此阶段尚未构建 HTTP 服务器。若测试代码依赖于 `httpAdapter`，必须使用 `createNestApplication()` 来初始化完整应用，或重构架构以移除对该适配器的直接依赖。

- `app.getHttpServer()` 返回底层 HTTP 服务实例（如 Express 应用）。
- 将该实例传入 `request()`，Supertest 便可模拟 HTTP 请求并路由至 Nest 应用处理逻辑。
- 测试代码中调用 `.get('/cats')` 即模拟一次 `GET /cats` 请求，并断言其响应结构。

此外，示例中我们为 `CatsService` 提供了一个**测试替身**（test double），用于模拟返回值，避免测试依赖真实业务逻辑。通过 `overrideProvider()` 方法，我们可以用任意对象替换默认提供者，实现依赖隔离。

Nest 同样提供一系列类似的覆盖方法：

| 方法                    | 说明             |
| ----------------------- | ---------------- |
| `overrideProvider()`    | 替换服务提供者。 |
| `overrideModule()`      | 替换整个模块。   |
| `overrideGuard()`       | 替换守卫。       |
| `overrideInterceptor()` | 替换拦截器。     |
| `overrideFilter()`      | 替换异常过滤器。 |
| `overridePipe()`        | 替换管道。       |

除了 `overrideModule()` 外，其余方法均返回一个支持链式调用的构建器对象，可使用以下工厂方法配置替代项：

- `useClass()`：指定一个新类，由 Nest 实例化后用于替换原对象。
- `useValue()`：传入一个已实例化的值，直接替换原对象。
- `useFactory()`：提供一个工厂函数，Nest 执行该函数并使用其返回值作为替代。

`overrideModule()` 则返回一个包含 `useModule()` 的对象，允许你用另一个模块替代原模块，例如：

```ts
const moduleRef = await Test.createTestingModule({
  imports: [AppModule],
})
  .overrideModule(CatsModule)
  .useModule(AlternateCatsModule)
  .compile()
```

整个链式调用会最终返回一个 `TestingModule` 实例，接着调用 `.compile()` 即可完成模块初始化。

###进阶技巧：自定义日志器

在测试场景中（尤其是在 CI 流水线中运行时），你可能希望自定义日志输出行为。此时可以使用 setLogger() 方法为 TestModuleBuilder 提供一个自定义的日志器实例。只需实现 LoggerService 接口即可控制日志输出级别（默认仅输出 “error” 级别）。

### 编译后的测试模块方法一览

| 方法                       | 说明                                                        |
| -------------------------- | ----------------------------------------------------------- |
| `createNestApplication()`  | 创建一个完整的 Nest 应用实例，需调用 init() 进行初始化。    |
| `createNestMicroservice()` | 创建并返回一个 Nest 微服务实例。                            |
| `get()`                    | 获取应用上下文中静态提供的实例（控制器、服务等）。          |
| `resolve()`                | 获取动态作用域（如请求作用域）下的实例，适用于瞬态服务等。  |
| `select()`                 | 在模块图中导航，结合 get() 使用以访问指定模块下的特定实例。 |

<CalloutInfo>
  建议将端到端测试文件统一放置在 `test/` 目录下，并以 `.e2e-spec.ts`
  作为文件名结尾，以便识别和管理。
</CalloutInfo>

## 覆盖全局注册的增强器

在 Nest 应用中，守卫、管道、拦截器和异常过滤器等增强器（Enhancer）通常会以全局方式注册，例如：

```ts
providers: [
  {
    provide: APP_GUARD,
    useClass: JwtAuthGuard,
  },
],
```

上述写法通过 `APP_*` 令牌将 `JwtAuthGuard` 注册为全局守卫。由于这类注册方式会让 Nest 自动实例化目标类，因此在测试环境下**无法直接替换**守卫的实现。

为实现测试时的替换，需要将注册方式改为基于已有的提供者引用：

```ts
providers: [
  {
    provide: APP_GUARD,
    useExisting: JwtAuthGuard,
    // ^^^^^^^^ 注意这里用 useExisting 替代 useClass
  },
  JwtAuthGuard, // 显式声明为可被覆盖的普通提供者
],
```

<CalloutInfo>
  将 `useClass` 替换为 `useExisting`，意味着 Nest 将引用已注册的 `JwtAuthGuard`
  实例，而不再为其单独创建实例。这样一来，该守卫就具备了可覆盖性。
</CalloutInfo>

通过这种方式，`JwtAuthGuard` 将作为常规提供者注册，进而允许在测试模块中进行替换。例如：

```ts
const moduleRef = await Test.createTestingModule({
  imports: [AppModule],
})
  .overrideProvider(JwtAuthGuard)
  .useClass(MockAuthGuard)
  .compile()
```

此时，所有测试请求将使用 `MockAuthGuard` 替代原本的 `JwtAuthGuard`，从而实现更灵活的测试场景模拟。

## 测试请求作用域的实例

[请求作用域](/fundamentals/injection-scopes)（Request-scoped） 的提供者会在每次传入请求时单独实例化，待请求处理完毕后即被销毁。这种行为虽然适合大多数运行时场景，但在测试中却带来了一个问题：我们无法直接访问某次请求所创建的依赖注入子树。

如前文所述，可以借助 `resolve()` 方法动态获取实例。进一步地，正如此处所介绍的，我们可以为每次解析操作提供一个**上下文标识符**（context identifier），以控制 DI 容器中子树的生命周期。那么在测试中，该如何利用这一机制？

### 核心思路

预先生成一个上下文标识符，并强制 Nest 在每次请求中复用这个标识符。这样一来，我们就能跨请求访问特定的依赖实例，实现测试中的精确控制。

### 示例代码

通过 `jest.spyOn()` 模拟 `ContextIdFactory` 的行为：

```ts
const contextId = ContextIdFactory.create()
jest.spyOn(ContextIdFactory, 'getByRequest').mockImplementation(() => contextId)
```

接着，就可以使用这个 contextId 来解析对应请求作用域下的服务实例：

```ts
catsService = await moduleRef.resolve(CatsService, contextId)
```

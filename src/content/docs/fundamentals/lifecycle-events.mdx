# 生命周期事件

Nest 应用程序及其组成部分都受框架生命周期机制的统一管理。Nest 提供了一套**生命周期钩子**（Lifecycle Hooks），允许你在应用的不同阶段插入自定义逻辑，例如在模块、提供者或控制器中执行初始化或清理操作。

## 生命周期流程

下图展示了从应用启动到 Node.js 进程退出期间，各个生命周期事件的调用顺序。整个生命周期可以划分为三个阶段：**初始化**（initializing）、**运行中**（running） 和**终止中**（terminating）。

理解这三个阶段的执行流程，有助于你合理安排服务的初始化、连接的管理，以及在收到关闭信号时实现应用的**优雅退出**。

```mermaid
flowchart TD
    Start([启动应用]) --> Deps[依赖注入容器<br/>解析模块依赖]
    Deps --> ModInit[onModuleInit<br/>各模块逐一初始化<br/>执行初始化逻辑]
    ModInit --> AppBoot[onApplicationBootstrap<br/>所有模块初始化完成<br/>应用引导阶段完成]
    AppBoot --> Listen[启动服务监听器<br/>HTTP服务器 / WebSocket服务器<br/>开始接受连接]
    Listen --> Running{应用运行中<br/>处理用户请求<br/>执行业务逻辑}

    Running -->|正常运行| Running
    Running -->|收到终止信号| Signal[接收终止信号<br/>SIGTERM / SIGINT<br/>开始优雅关闭流程]

    Signal --> ModDest[onModuleDestroy<br/>通知各模块准备销毁<br/>清理模块级资源]
    ModDest --> BeforeShut[beforeApplicationShutdown<br/>所有模块销毁完成<br/>准备关闭应用连接]
    BeforeShut --> StopListen[停止监听器<br/>拒绝新连接<br/>等待现有请求完成]
    StopListen --> AppShut[onApplicationShutdown<br/>所有连接已关闭<br/>执行最终清理工作]
    AppShut --> Exit([进程退出])

    subgraph init [初始化阶段]
        Deps
        ModInit
        AppBoot
        Listen
    end

    subgraph run [运行阶段]
        Running
    end

    subgraph term [终止阶段]
        Signal
        ModDest
        BeforeShut
        StopListen
        AppShut
    end
```

## 生命周期事件

在应用启动与关闭过程中，Nest 会依照特定的生命周期阶段，自动调用已注册的生命周期钩子方法（Lifecycle Hook Method）。这些钩子可定义在模块、提供者或控制器中，用于在特定节点执行自定义逻辑（关于关闭阶段的钩子，需先启用，详见[下文](/fundamentals/lifecycle-events#application-shutdown)）。

如上图所示，Nest 除了调用各类钩子方法，还会在底层管理应用的连接监听状态（启动/停止）。

需要注意的是，某些生命周期钩子仅在应用显式调用 `app.init()` 或 `app.listen()` 时才会触发，例如：

- `onModuleInit`
- `onApplicationBootstrap`

而应用关闭阶段的钩子 —— 如 `onModuleDestroy`、`beforeApplicationShutdown` 和 `onApplicationShutdown` —— 则需在调用 `app.close()`，或进程接收到诸如 `SIGTERM` 等系统信号时才会生效。此外，响应系统信号还要求显式启用关闭钩子（详见下文应用关闭）。

### 生命周期钩子与对应事件

| 生命周期钩子方法                | 触发钩子方法调用的生命周期事件                                                                                                 |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| `onModuleInit()`                | 宿主模块的依赖关系解析完成后执行。                                                                                             |
| `onApplicationBootstrap()`      | 所有模块完成初始化，但尚未开始监听连接之前执行。                                                                               |
| `onModuleDestroy()`\*           | 应用收到终止信号（如 SIGTERM）后触发。                                                                                         |
| `beforeApplicationShutdown()`\* | 所有模块的 `onModuleDestroy()` 钩子执行完毕（即相关 `Promise` 被解析或拒绝）后调用；随后将关闭所有连接，等同于 `app.close()`。 |
| `onApplicationShutdown()`\*     | 应用连接关闭完成（`app.close()` 已解析）后调用。                                                                               |

\* 上述钩子不会在默认情况下响应系统信号，需调用 `app.enableShutdownHooks()` 主动启用。

<CalloutInfo type="warning">
  生命周期钩子**不会**在请求作用域类中触发。

这是因为请求作用域类的实例在每个请求中动态创建，生命周期受请求驱动，且会在响应结束后被自动销毁，不参与应用生命周期管理。

</CalloutInfo>

<CalloutInfo>
  `onModuleInit()` 与 `onApplicationBootstrap()`
  的执行顺序遵循模块的导入顺序，并将在前一个钩子完成后才继续执行下一个。
</CalloutInfo>

## 用法

Nest 中的每个生命周期钩子都对应一个接口。虽然这些接口在 TypeScript 编译后不会被保留，因此实现接口并非强制要求，但建议这么做，以便获得类型检查和更完善的编辑器智能提示。

要使用某个生命周期钩子，只需在类中（如控制器、提供者或模块）实现相应接口，并定义对应的方法。例如，若希望在模块初始化阶段执行自定义逻辑，只需实现 `OnModuleInit` 接口并定义 `onModuleInit()` 方法，如下所示：

```ts
import { Injectable, OnModuleInit } from '@nestjs/common'

@Injectable()
export class UsersService implements OnModuleInit {
  onModuleInit() {
    console.log(`The module has been initialized.`)
  }
}
```

## 异步初始化

`OnModuleInit` 和 `OnApplicationBootstrap` 生命周期钩子支持异步操作。换言之，这些钩子方法可以返回 `Promise`，也可以使用 `async/await` 来执行异步任务。通过这种方式，可以在模块初始化或应用启动阶段执行需要等待完成的逻辑，从而有效地延迟整个初始化流程的推进。

```ts
async onModuleInit(): Promise<void> {
  await this.fetch();
}
```

## 应用关闭机制

在应用终止过程中，Nest 会依次触发以下生命周期钩子：

- `onModuleDestroy()`
- `beforeApplicationShutdown()`
- `onApplicationShutdown()`

这些钩子会在显式调用 `app.close()`、或应用接收到如 SIGTERM 等系统信号时被执行（前提是你已手动启用了关闭钩子监听）。

此机制在容器化部署场景中尤为重要，例如在 [Kubernetes](https://kubernetes.io/) 中管理 Pod 生命周期，或在 [Heroku](https://www.heroku.com/) 上处理 dyno 关闭等情况。

### 启用关闭钩子

出于性能考虑，Nest 默认不会启用关闭钩子监听器。若需要使用，必须显式调用 `enableShutdownHooks()` 方法：

```ts
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule)

  // 启用关闭钩子
  app.enableShutdownHooks()

  await app.listen(process.env.PORT ?? 3000)
}

bootstrap()
```

<CalloutInfo type="warning" title="Windows 平台限制">
由于平台机制限制，Nest 在 Windows 上对关闭钩子的支持存在差异。例如 `SIGINT`、`SIGBREAK` 和部分 `SIGHUP` 通常可以正常工作（详见 [Node.js 信号文档](https://nodejs.org/api/process.html#process_signal_events)）。但 `SIGTERM` 在 Windows 中始终无效，因为任务管理器直接终止进程时不会发送此信号，应用也无法感知或阻止该行为。

推荐阅读： [libuv 信号文档](https://docs.libuv.org/en/v1.x/signal.html)

</CalloutInfo>

<CalloutInfo title="多实例运行时的监听器限制">
  启用关闭钩子会注册进程监听器，增加内存占用。在单个 Node 进程中运行多个 Nest
  应用（如使用 Jest 并行测试）时，可能因监听器过多而触发 Node
  的警告提示。因此，`enableShutdownHooks()`
  默认关闭，使用时请评估实例数量和资源情况。
</CalloutInfo>

### 钩子执行顺序与信号传递

当应用收到终止信号（例如 `SIGINT`），Nest 会依照以下顺序调用生命周期钩子：

1. `onModuleDestroy()`
2. `beforeApplicationShutdown()`
3. `onApplicationShutdown(signal: string)`

如果这些钩子方法是异步的（即返回 Promise），Nest 会等待每个 `Promise` 被解析或拒绝后再继续执行下一个钩子。

示例：

```ts
@Injectable()
class UsersService implements OnApplicationShutdown {
  onApplicationShutdown(signal: string) {
    console.log(signal) // 输出接收到的信号，例如 "SIGINT"
  }
}
```

<CalloutInfo>
  `app.close()` 不会关闭 Node.js 进程，只会触发 `onModuleDestroy()` 与
  `onApplicationShutdown()`
  钩子。如果应用中存在定时器、长时间运行的任务等，进程仍会继续运行，需手动清理或调用
  `process.exit()`。
</CalloutInfo>

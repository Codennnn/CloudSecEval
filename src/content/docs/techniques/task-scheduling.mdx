# 任务调度

任务调度（Task scheduling）让你可以按照固定的日期、时间、周期性间隔，或在指定间隔后执行任意代码（方法或函数）。在 Linux 世界中，这类功能通常由操作系统层面的 [cron](https://en.wikipedia.org/wiki/Cron) 等软件包实现。对于 Node.js 应用，有多个软件包可以模拟类似 cron 的功能。Nest 提供了 `@nestjs/schedule` 包，该包集成了流行的 Node.js [cron](https://github.com/kelektiv/node-cron) 包。本章将介绍如何使用该包实现任务调度。

## 安装

要使用任务调度功能，首先需要安装相关依赖。

```bash
$ npm install --save @nestjs/schedule
```

接下来，在根模块（AppModule）中导入 `ScheduleModule`，并通过其静态方法 `forRoot()` 进行初始化：

```ts filename='app.module.ts'
import { Module } from '@nestjs/common'
import { ScheduleModule } from '@nestjs/schedule'

@Module({
  imports: [ScheduleModule.forRoot()],
})
export class AppModule {}
```

调用 `.forRoot()` 方法会初始化调度器，并注册应用中所有声明式的[定时任务（cron jobs）](/techniques/task-scheduling#declarative-cron-jobs)、[超时任务（timeouts）](/techniques/task-scheduling#declarative-timeouts) 和[间隔任务（intervals）](/techniques/task-scheduling#declarative-intervals)。这些任务会在 `onApplicationBootstrap` 生命周期钩子（lifecycle hook）触发时统一注册，确保所有模块都已加载并声明了各自的调度任务。

## 声明式定时任务

定时任务用于自动调度执行任意函数（方法调用）。你可以通过定时任务实现以下功能：

- 在指定的日期或时间执行一次任务。
- 按设定周期重复执行任务，例如：每小时、每周或每 5 分钟执行一次。

只需在方法定义前添加 `@Cron()` 装饰器（Decorator），即可声明一个定时任务。被装饰的方法中包含需要自动执行的代码。示例：

```ts
import { Injectable, Logger } from '@nestjs/common'
import { Cron } from '@nestjs/schedule'

@Injectable()
export class TasksService {
  private readonly logger = new Logger(TasksService.name)

  @Cron('45 * * * * *')
  handleCron() {
    this.logger.debug('当当前秒数为 45 时调用')
  }
}
```

在上述示例中，`handleCron()` 方法会在每分钟的第 45 秒自动执行一次。

`@Cron()` 装饰器支持标准的 [cron 表达式](http://crontab.org/)，包括：

- 星号（如：`*`）
- 范围（如：`1-3,5`）
- 步进（如：`*/2`）

以 `45 * * * * *` 为例，下面是 cron 表达式每个位置的含义：

```
* * * * * *
| | | | | |
| | | | | +-- 星期几 (0 - 7)（星期日为 0 或 7）
| | | | +---- 月份 (1 - 12)
| | | +------ 每月的第几天 (1 - 31)
| | +-------- 小时 (0 - 23)
| +---------- 分钟 (0 - 59)
+------------ 秒（可选）(0 - 59)
```

以下是一些常用 cron 表达式示例：

| Cron 表达式         | 说明                                          |
| ------------------- | --------------------------------------------- |
| `* * * * * *`       | 每秒执行一次                                  |
| `45 * * * * *`      | 每分钟的第 45 秒执行                          |
| `0 10 * * * *`      | 每小时的第 10 分钟开始时执行                  |
| `0 */30 9-17 * * *` | 每天 9:00 至 17:00 之间，每隔 30 分钟执行一次 |
| `0 30 11 * * 1-5`   | 每周一至周五的 11:30 执行                     |

`@nestjs/schedule` 包内置了常用 cron 表达式（Cron Expression）枚举，方便直接引用。例如：

```ts
import { Injectable, Logger } from '@nestjs/common'
import { Cron, CronExpression } from '@nestjs/schedule'

@Injectable()
export class TasksService {
  private readonly logger = new Logger(TasksService.name)

  @Cron(CronExpression.EVERY_30_SECONDS)
  handleCron() {
    this.logger.debug('每 30 秒调用一次')
  }
}
```

如上，`handleCron()` 方法会每隔 30 秒自动执行一次。若发生异常，异常信息会被记录到控制台，因为所有使用 `@Cron()` 装饰器的方法都会被自动包裹在 `try-catch` 语句块中。

此外，你还可以为 `@Cron()` 装饰器传入一个 JavaScript 的 `Date` 对象，让任务在指定日期和时间仅执行一次。

<CalloutInfo>
  你可以利用 JavaScript 的日期运算来实现相对当前时间的定时任务。例如，`@Cron(new Date(Date.now() +
  10 * 1000))` 可让任务在应用启动后 10 秒执行一次。
</CalloutInfo>

`@Cron()` 装饰器还支持第二个参数，用于传递额外选项：

| 选项                | 说明                                                                                                                                                       |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`              | 用于在声明后访问和控制定时任务（cron job）。                                                                                                               |
| `timeZone`          | 指定任务执行时所用的时区。会根据你的时区调整实际执行时间。若时区无效，将抛出错误。可在 [Moment Timezone](http://momentjs.com/timezone/) 查询所有可用时区。 |
| `utcOffset`         | 通过设置偏移量（offset）指定时区，而不是直接使用 `timeZone` 参数。                                                                                         |
| `waitForCompletion` | 若设为 `true`，则当前 onTick 回调未执行完前，不会启动新的定时任务实例。任务运行期间发生的新调度会被跳过。                                                  |
| `disabled`          | 指定该任务是否会被执行。                                                                                                                                   |

```ts
import { Injectable } from '@nestjs/common'
import { Cron, CronExpression } from '@nestjs/schedule'

@Injectable()
export class NotificationService {
  @Cron('* * 0 * * *', {
    name: 'notifications',
    timeZone: 'Europe/Paris',
  })
  triggerNotifications() {}
}
```

你可以在声明后访问和控制定时任务，也可以通过[动态 API](/techniques/task-scheduling#dynamic-schedule-module-api) 动态创建定时任务（即在运行时定义 cron 表达式）。要通过 API 访问声明式定时任务，需在装饰器第二个参数 options 对象中通过 `name` 属性为任务指定名称。

## 声明式周期执行任务

如果你希望让某个方法以指定的（周期性）间隔自动执行，只需在方法定义前添加 `@Interval()` 装饰器。如下所示，将间隔时间（以毫秒为单位的数字）作为参数传递给装饰器：

```ts
@Interval(10000)
handleInterval() {
  this.logger.debug('每 10 秒调用一次');
}
```

<CalloutInfo>
  该机制底层依赖 JavaScript 的 `setInterval()` 函数。同时，你也可以使用 cron 任务来调度周期性任务。
</CalloutInfo>

如果你希望通过[动态 API](/techniques/task-scheduling#dynamic-schedule-module-api) 在类的外部控制声明式定时任务，可以为定时任务指定名称，示例如下：

```ts
@Interval('notifications', 2500)
handleInterval() {}
```

当方法执行过程中发生异常时，异常信息会被记录到控制台。因为所有使用 `@Interval()` 装饰器的方法，都会被自动包裹在 `try-catch` 代码块中。

[动态 API](/techniques/task-scheduling#dynamic-intervals) 还支持创建动态定时任务（dynamic intervals），即可以在运行时定义定时任务的属性，并且能够列出和删除这些任务。

## 声明式超时执行任务

要声明某个方法在指定超时时间后（仅一次）运行，只需在方法定义前添加 `@Timeout()` 装饰器。如下所示，将相对于应用启动时间的延迟（以毫秒为单位）作为参数传递给装饰器：

```ts
@Timeout(5000)
handleTimeout() {
  this.logger.debug('在 5 秒后调用一次');
}
```

<CalloutInfo>

该机制底层使用了 JavaScript 的 `setTimeout()` 函数。

</CalloutInfo>

如果发生异常，异常信息会被记录到控制台，因为所有使用 `@Timeout()` 装饰器的方法都会被自动包裹在 `try-catch` 代码块中。

如果你希望通过[动态 API](/techniques/task-scheduling#dynamic-schedule-module-api) 在声明类外部控制声明式超时任务，可以通过如下方式为超时任务指定名称：

```ts
@Timeout('notifications', 2500)
handleTimeout() {}
```

[动态 API](/techniques/task-scheduling#dynamic-timeouts)还支持创建动态超时任务（dynamic
timeouts），即在运行时定义超时任务的属性，并且可以列出和删除这些任务。

## 动态调度模块 API

`@nestjs/schedule` 模块提供了一个灵活的 API，支持管理声明式的[定时任务](/techniques/task-scheduling#declarative-cron-jobs)、[超时（timeouts）](/techniques/task-scheduling#declarative-timeouts) 和[间隔任务（intervals）](/techniques/task-scheduling#declarative-intervals)。此外，该 API 还允许你在运行时动态创建和管理定时任务、超时和间隔任务。

## 动态定时任务

你可以通过 `SchedulerRegistry` API，在代码的任意位置按名称获取 `CronJob` 实例。首先，使用标准的依赖注入方式注入 `SchedulerRegistry`：

```ts
constructor(private schedulerRegistry: SchedulerRegistry) {}
```

<CalloutInfo>

请从 `@nestjs/schedule` 包中导入 `SchedulerRegistry`。

</CalloutInfo>

假设你已经如下声明了一个定时任务：

```ts
@Cron('* * 8 * * *', {
  name: 'notifications',
})
triggerNotifications() {}
```

你可以通过以下方式访问该任务：

```ts
const job = this.schedulerRegistry.getCronJob('notifications')

job.stop()
console.log(job.lastDate())
```

`getCronJob()` 方法会返回指定名称的定时任务。返回的 `CronJob` 对象包含以下常用方法：

- `stop()` - 停止当前计划的任务。
- `start()` - 重新启动已停止的任务。
- `setTime(time: CronTime)` - 停止任务，设置新的时间后重新启动。
- `lastDate()` - 返回该任务上一次执行的日期（`DateTime` 类型）。
- `nextDate()` - 返回该任务下一次计划执行的日期（`DateTime` 类型）。
- `nextDates(count: number)` - 返回一个数组（长度为 `count`），包含该任务接下来将被触发的日期（`DateTime` 类型）。`count` 默认为 0，此时返回空数组。

<CalloutInfo>
  你可以对 `DateTime` 对象调用 `toJSDate()` 方法，将其转换为 JavaScript 的 `Date` 类型。
</CalloutInfo>

**动态创建** 新定时任务时，可以使用 `SchedulerRegistry#addCronJob` 方法，示例如下：

```ts
addCronJob(name: string, seconds: string) {
  const job = new CronJob(`${seconds} * * * * *`, () => {
    this.logger.warn(`time (${seconds}) for job ${name} to run!`);
  });

  this.schedulerRegistry.addCronJob(name, job);
  job.start();

  this.logger.warn(
    `job ${name} added for each minute at ${seconds} seconds!`,
  );
}
```

在上述代码中，我们使用 `cron` 包中的 `CronJob` 类来创建定时任务。`CronJob` 构造函数的第一个参数是 cron 表达式（与 `@Cron()` [装饰器](/techniques/task-scheduling#declarative-cron-jobs)用法一致），第二个参数是定时器触发时要执行的回调函数。`SchedulerRegistry#addCronJob` 方法接收两个参数：任务名称和 `CronJob` 实例。

<CalloutInfo type="warning">
  在访问 `SchedulerRegistry` 之前，务必先注入它。`CronJob` 需要从 `cron` 包中导入。
</CalloutInfo>

**删除** 指定名称的定时任务，可以使用 `SchedulerRegistry#deleteCronJob` 方法，示例如下：

```ts
deleteCron(name: string) {
  this.schedulerRegistry.deleteCronJob(name);
  this.logger.warn(`job ${name} deleted!`);
}
```

**列出** 所有定时任务，可以使用 `SchedulerRegistry#getCronJobs` 方法，示例如下：

```ts
getCrons() {
  const jobs = this.schedulerRegistry.getCronJobs();
  jobs.forEach((value, key, map) => {
    let next;
    try {
      next = value.nextDate().toJSDate();
    } catch (e) {
      next = 'error: next fire date is in the past!';
    }
    this.logger.log(`job: ${key} -> next: ${next}`);
  });
}
```

`getCronJobs()` 方法会返回一个 `map`。在上述代码中，我们遍历该 map，并尝试访问每个 `CronJob` 的 `nextDate()` 方法。如果任务已经执行完毕且没有未来的触发时间，`CronJob` 的 API 会抛出异常。

## 动态定时任务间隔

你可以通过 `SchedulerRegistry#getInterval` 方法获取指定定时任务（interval）的引用。首先，使用标准的构造函数依赖注入方式注入 `SchedulerRegistry`：

```ts
constructor(private schedulerRegistry: SchedulerRegistry) {}
```

然后可以这样获取并清除定时任务：

```ts
const interval = this.schedulerRegistry.getInterval('notifications')
clearInterval(interval)
```

如果需要**动态创建**新的定时任务间隔，可以使用 `SchedulerRegistry#addInterval` 方法。例如：

```ts
addInterval(name: string, milliseconds: number) {
  const callback = () => {
    this.logger.warn(`Interval ${name} executing at time (${milliseconds})!`);
  };

  const interval = setInterval(callback, milliseconds);
  this.schedulerRegistry.addInterval(name, interval);
}
```

上述代码中，先创建了一个标准的 JavaScript 定时任务（interval），再通过 `SchedulerRegistry#addInterval` 方法将其注册到调度器中。
该方法接收两个参数：定时任务的名称和定时任务对象本身。

如需**删除**指定名称的定时任务，可以使用 `SchedulerRegistry#deleteInterval` 方法。例如：

```ts
deleteInterval(name: string) {
  this.schedulerRegistry.deleteInterval(name);
  this.logger.warn(`Interval ${name} deleted!`);
}
```

要**列出**所有已注册的定时任务，可以使用 `SchedulerRegistry#getIntervals` 方法。例如：

```ts
getIntervals() {
  const intervals = this.schedulerRegistry.getIntervals();
  intervals.forEach(key => this.logger.log(`Interval: ${key}`));
}
```

## 动态超时任务

你可以通过 `SchedulerRegistry#getTimeout` 方法获取指定超时任务（timeout）的引用。首先，使用标准的构造函数依赖注入方式注入 `SchedulerRegistry`：

```ts
constructor(private readonly schedulerRegistry: SchedulerRegistry) {}
```

然后可以这样获取并清除超时任务：

```ts
const timeout = this.schedulerRegistry.getTimeout('notifications')
clearTimeout(timeout)
```

如果需要**动态创建**新的超时任务，可以使用 `SchedulerRegistry#addTimeout` 方法。例如：

```ts
addTimeout(name: string, milliseconds: number) {
  const callback = () => {
    this.logger.warn(`Timeout ${name} executing after (${milliseconds})!`);
  };

  const timeout = setTimeout(callback, milliseconds);
  this.schedulerRegistry.addTimeout(name, timeout);
}
```

上述代码中，先创建了一个标准的 JavaScript 超时任务（timeout），再通过 `SchedulerRegistry#addTimeout` 方法注册到调度器中。
该方法同样接收两个参数：超时任务的名称和超时对象本身。

如需**删除**指定名称的超时任务，可以使用 `SchedulerRegistry#deleteTimeout` 方法。例如：

```ts
deleteTimeout(name: string) {
  this.schedulerRegistry.deleteTimeout(name);
  this.logger.warn(`Timeout ${name} deleted!`);
}
```

要**列出**所有已注册的超时任务，可以使用 `SchedulerRegistry#getTimeouts` 方法。例如：

```ts
getTimeouts() {
  const timeouts = this.schedulerRegistry.getTimeouts();
  timeouts.forEach(key => this.logger.log(`Timeout: ${key}`));
}
```

## 示例

完整的可用示例请参考[官方仓库示例](https://github.com/nestjs/nest/tree/master/sample/27-scheduling)。

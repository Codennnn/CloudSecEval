# Session

**HTTP session（会话）** 提供了一种在多个请求之间存储用户信息的机制，这对于 [MVC](/techniques/mvc) 应用场景尤为重要。

## 在 Express（默认）中使用

首先需要安装[所需依赖包](https://github.com/expressjs/session)（如果你使用 TypeScript，还需安装类型声明）：

```bash
$ npm i express-session
$ npm i -D @types/express-session
```

安装完成后，在全局中间件中引入并应用 `express-session` 中间件（例如在 `main.ts` 文件中）：

```ts
import * as session from 'express-session'
// 在初始化文件中
app.use(
  session({
    secret: 'my-secret',
    resave: false,
    saveUninitialized: false,
  })
)
```

<CalloutInfo type="warning">
  默认的服务端会话存储并不适合生产环境。在大多数情况下，这种方式会导致内存泄漏，且无法扩展到多进程环境，因此仅推荐用于调试和开发阶段。详细说明请参阅[官方仓库](https://github.com/expressjs/session)。
</CalloutInfo>

`secret` 用于为会话 ID Cookie 进行签名。它可以是单个字符串（单一密钥），也可以是字符串数组（多个密钥）。如果传入密钥数组，只有第一个元素会用于签名会话 ID Cookie，所有元素都会在请求时用于校验签名。密钥本身应足够复杂，建议使用随机字符。

启用 `resave` 选项会强制每次请求都将会话保存到存储中，即使会话内容没有发生变化。该选项的默认值为 `true`，但此默认值已被弃用，未来版本可能会更改。

同样，启用 `saveUninitialized` 选项会强制将"未初始化"的会话保存到存储中。所谓"未初始化"，是指新建但尚未被修改的会话。将其设置为 `false`，有助于实现登录会话、减少服务器存储消耗，或满足需要用户同意后才能设置 Cookie 的法律要求。此外，设置为 `false` 还可以避免客户端在没有会话的情况下并发发起多个请求时出现竞态条件（[参考来源](https://github.com/expressjs/session#saveuninitialized)）。

你还可以为 `session` 中间件传递更多配置选项，详见 [API 文档](https://github.com/expressjs/session#options)。

<CalloutInfo>
  推荐设置 `secure: true` 选项。但请注意，启用该选项要求你的网站必须通过 HTTPS 访问，即只有在 HTTPS
  下才会设置安全 Cookie。如果设置了 `secure: true`，但通过 HTTP 访问网站，则不会设置
  Cookie。如果你的 Node.js 应用部署在代理服务器后，并且使用了 `secure: true`，还需要在 express
  中设置 `"trust proxy"`。
</CalloutInfo>

配置完成后，你可以在路由处理器（Route Handler）中设置和读取会话值，例如：

```ts
@Get()
findAll(@Req() request: Request) {
  request.session.visits = request.session.visits ? request.session.visits + 1 : 1;
}
```

<CalloutInfo>
  `@Req()` 装饰器需从 `@nestjs/common` 导入，`Request` 类型来自 `express` 包。
</CalloutInfo>

你也可以使用 `@Session()` 装饰器，直接从请求中提取会话对象，示例如下：

```ts
import { Session } from '@nestjs/common'

@Get()
findAll(@Session() session: Record<string, any>) {
  session.visits = session.visits ? session.visits + 1 : 1;
}
```

## 在 Fastify 中使用

首先，安装所需依赖包：

```bash
$ npm i @fastify/secure-session
```

安装完成后，在初始化文件中注册 `fastify-secure-session` 插件：

```ts
import secureSession from '@fastify/secure-session'

// 在你的初始化文件中
const app = await NestFactory.create<NestFastifyApplication>(AppModule, new FastifyAdapter())
await app.register(secureSession, {
  secret: 'averylogphrasebiggerthanthirtytwochars', // 建议使用长度大于 32 个字符的密钥
  salt: 'mq9hDxBVDbspDR6n',
})
```

<CalloutInfo>
  你也可以预先生成密钥（[查看说明](https://github.com/fastify/fastify-secure-session)），或者使用[密钥轮换](https://github.com/fastify/fastify-secure-session#using-keys-with-key-rotation)功能。
</CalloutInfo>

更多可用选项请参考[官方仓库](https://github.com/fastify/fastify-secure-session)。

完成上述配置后，你就可以在路由处理器（Route Handler）中设置和读取会话（session）值。例如：

```ts
@Get()
findAll(@Req() request: FastifyRequest) {
  const visits = request.session.get('visits');
  // 记录访问次数，每次请求加 1
  request.session.set('visits', visits ? visits + 1 : 1);
}
```

此外，你还可以使用 `@Session()` 装饰器，从请求中直接提取会话对象。示例如下：

```ts
@Get()
findAll(@Session() session: secureSession.Session) {
  const visits = session.get('visits');
  // 记录访问次数，每次请求加 1
  session.set('visits', visits ? visits + 1 : 1);
}
```

<CalloutInfo>
  `@Session()` 装饰器需要从 `@nestjs/common` 导入，而 `secureSession.Session` 类型则来自
  `@fastify/secure-session` 包（导入方式：`import * as secureSession from
  '@fastify/secure-session'`）。
</CalloutInfo>

# Cookie

**HTTP Cookie** 是一种由用户浏览器存储的小型数据片段。Cookie 的设计初衷，是让网站能够可靠地记住有状态的信息，当用户再次访问网站时，浏览器会自动将 Cookie 随请求一同发送给服务器。

## 在 Express（默认）中使用

首先需要安装[所需依赖包](https://github.com/expressjs/cookie-parser)（如果你使用 TypeScript，还需安装类型声明）：

```bash
$ npm i cookie-parser
$ npm i -D @types/cookie-parser
```

安装完成后，将 `cookie-parser` 中间件作为全局中间件应用。例如，可以在你的 `main.ts` 文件中这样配置：

```ts
import * as cookieParser from 'cookie-parser'
// 在应用初始化阶段
app.use(cookieParser())
```

你可以为 `cookieParser` 中间件传递多个选项参数：

- `secret`：用于签名 Cookie 的字符串或字符串数组。该参数为可选项。如果未指定，则不会解析已签名的 Cookie。若传入字符串，则该字符串作为密钥使用；若传入数组，则会依次尝试用每个密钥对 Cookie 进行解签。
- `options`：一个对象，会作为第二个参数传递给 `cookie.parse`。更多信息请参见 [cookie](https://www.npmjs.org/package/cookie)。

该中间件会解析请求头（Header）中的 `Cookie`，并将 Cookie 数据暴露为 `req.cookies` 属性。如果提供了密钥，还会暴露为 `req.signedCookies` 属性。这些属性都是以 Cookie 名称为键、Cookie 值为值的对象。

当提供了密钥时，模块会对所有已签名的 Cookie 值进行解签和校验，并将这些键值对从 `req.cookies` 移动到 `req.signedCookies`。已签名的 Cookie 指的是值以 `s:` 前缀开头的 Cookie。如果签名校验失败，对应的 Cookie 值会被设置为 `false`，而不是被篡改的值。

完成上述配置后，你就可以在路由处理器（Route Handler）中读取 Cookie，例如：

```ts
@Get()
findAll(@Req() request: Request) {
  console.log(request.cookies) // 或 "request.cookies['cookieKey']"
  // 或 console.log(request.signedCookies)
}
```

<CalloutInfo>
  `@Req()` 装饰器需从 `@nestjs/common` 导入，`Request` 类型需从 `express` 包导入。
</CalloutInfo>

如果需要在响应对象（Response Object）中设置 Cookie，可以使用 `Response#cookie()` 方法：

```ts
@Get()
findAll(@Res({ passthrough: true }) response: Response) {
  response.cookie('key', 'value')
}
```

<CalloutInfo type="warning">
  如果你希望将响应处理逻辑交由框架处理，请务必如上所示将 `passthrough` 选项设置为
  `true`。详细说明请参见[此处](/controllers#library-specific-approach)。
</CalloutInfo>

<CalloutInfo>
  `@Res()` 装饰器需从 `@nestjs/common` 导入，`Response` 类型需从 `express` 包导入。
</CalloutInfo>

## 在 Fastify 中使用

首先，安装所需依赖包：

```bash
$ npm i @fastify/cookie
```

安装完成后，需要在应用中注册 `@fastify/cookie` 插件：

```ts
import fastifyCookie from '@fastify/cookie'

// 在初始化文件中
const app = await NestFactory.create<NestFastifyApplication>(AppModule, new FastifyAdapter())
await app.register(fastifyCookie, {
  secret: 'my-secret', // 用于 Cookie 签名
})
```

完成上述配置后，你就可以在路由处理器中读取 Cookie 了。例如：

```ts
@Get()
findAll(@Req() request: FastifyRequest) {
  console.log(request.cookies) // 或 "request.cookies['cookieKey']"
}
```

<CalloutInfo>
  `@Req()` 装饰器需从 `@nestjs/common` 导入，`FastifyRequest` 则来自 `fastify` 包。
</CalloutInfo>

如果需要在响应中设置 Cookie，可以使用 `FastifyReply#setCookie()` 方法：

```ts
@Get()
findAll(@Res({ passthrough: true }) response: FastifyReply) {
  response.setCookie('key', 'value')
}
```

如需了解更多关于 `FastifyReply#setCookie()` 方法的用法，请参阅[官方文档](https://github.com/fastify/fastify-cookie#sending)。

<CalloutInfo type="warning">
  如果你希望将响应处理逻辑交由框架处理，请务必如上例所示，将 `passthrough` 选项设置为
  `true`。详细说明可参考 [这里](/controllers#library-specific-approach)。
</CalloutInfo>

<CalloutInfo>
  `@Res()` 装饰器需从 `@nestjs/common` 导入，`FastifyReply` 则来自 `fastify` 包。
</CalloutInfo>

## 创建自定义装饰器（跨平台通用）

为了让你能够更便捷、声明式地访问请求中的 Cookie，我们可以创建一个[自定义装饰器](/custom-decorators)。

```ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common'

// Cookies 装饰器：用于获取请求中的 Cookie
export const Cookies = createParamDecorator((data: string, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest()
  // 如果传入参数，则返回指定名称的 Cookie，否则返回全部 Cookie
  return data ? request.cookies?.[data] : request.cookies
})
```

`@Cookies()` 装饰器会从 `req.cookies` 对象中提取所有 Cookie。你也可以通过传入参数，获取指定名称的 Cookie。最终，获取到的值会赋给被装饰的参数。

有了这个装饰器后，你可以在路由处理器方法的参数中直接这样使用：

```ts
@Get()
findAll(@Cookies('name') name: string) {
  // 这里的 name 参数会自动获取名为 'name' 的 Cookie
}
```

# 序列化

序列化（Serialization）是在对象返回到网络响应之前，对其进行转换和清理的过程。在这个阶段，我们可以对即将返回给客户端的数据进行处理，比如脱敏操作。例如，像密码这样的敏感信息应始终从响应中移除，或者有些属性可能需要额外转换，比如只返回实体的一部分属性。手动完成这些转换不仅繁琐，还容易遗漏各种场景。

## 概述

Nest 提供了内置能力，帮助你以简单直观的方式完成这些操作。`ClassSerializerInterceptor` 拦截器基于强大的 [class-transformer](https://github.com/typestack/class-transformer) 包，提供了一种声明式、可扩展的对象转换方案。它的基本原理是获取方法处理器的返回值，并应用 [class-transformer](https://github.com/typestack/class-transformer) 的 `instanceToPlain()` 函数。在此过程中，会根据实体类或数据传输对象类上通过 class-transformer 装饰器声明的规则进行转换，具体如下所述。

<CalloutInfo>
  序列化不会应用于 [StreamableFile](/techniques/streaming-files#streamable-file-class) 类型的响应。
</CalloutInfo>

## 排除属性

假设我们希望自动从用户实体中排除 `password` 属性，可以像下面这样为实体类添加注解：

```ts
import { Exclude } from 'class-transformer'

export class UserEntity {
  id: number
  firstName: string
  lastName: string

  @Exclude()
  password: string

  constructor(partial: Partial<UserEntity>) {
    Object.assign(this, partial)
  }
}
```

来看一个控制器方法返回该类实例的例子：

```ts
import { ClassSerializerInterceptor } from '@nestjs/common'

@UseInterceptors(ClassSerializerInterceptor)
@Get()
findOne(): UserEntity {
  return new UserEntity({
    id: 1,
    firstName: 'John',
    lastName: 'Doe',
    password: 'password',
  });
}
```

<CalloutInfo type='warning'>
请注意，必须返回类的实例。如果你返回的是普通的 JavaScript 对象，例如 `{{ '{' }} user: new UserEntity() {{ '}' }}`，则无法被正确序列化。
</CalloutInfo>

当该端点被请求时，客户端会收到如下响应：

```json
{
  "id": 1,
  "firstName": "John",
  "lastName": "Doe"
}
```

需要注意的是，该拦截器可以应用于整个应用（详见[此处](/interceptors#binding-interceptors)）。拦截器与实体类声明的结合确保了**所有**返回 `UserEntity` 的方法都会自动移除 `password` 属性，从而实现了业务规则的集中式强制执行。

## 暴露属性

你可以使用 `@Expose()` 装饰器为属性设置别名，或者通过执行函数动态计算属性值（类似于 **getter** ），如下所示：

```ts
@Expose()
get fullName(): string {
  return `${this.firstName} ${this.lastName}`;
}
```

## 转换

你可以通过 `@Transform()` 装饰器实现额外的数据转换。例如，下面的用法会返回 `RoleEntity` 的 name 属性，而不是整个对象：

```ts
@Transform(({ value }) => value.name)
role: RoleEntity;
```

## 传递选项

有时你可能需要修改转换函数的默认行为。此时，可以通过 `@SerializeOptions()` 装饰器传递一个 `options` 对象来覆盖默认设置。

```ts
import { SerializeOptions } from '@nestjs/common'

@SerializeOptions({
  excludePrefixes: ['_'],
})
@Get()
findOne(): UserEntity {
  return new UserEntity();
}
```

通过 `@SerializeOptions()` 传递的选项，会作为底层 `instanceToPlain()` 函数的第二个参数。在本例中，所有以 `_` 开头的属性都会被自动排除。

## 转换普通对象

你可以在控制器层面统一应用转换逻辑，只需使用 `@SerializeOptions` 装饰器即可。这样可以确保所有响应都被转换为指定类的实例，并自动应用 class-validator 或 class-transformer 的装饰器，无论返回的是普通对象还是类实例。这种方式让代码更简洁，无需频繁实例化类或手动调用 `plainToInstance`。

在下面的示例中，无论条件分支返回的是普通 JavaScript 对象还是类实例，最终都会被自动转换为 `UserEntity` 实例，并应用相关装饰器：

```ts
@UseInterceptors(ClassSerializerInterceptor)
@SerializeOptions({ type: UserEntity })
@Get()
findOne(@Query() { id }: { id: number }): UserEntity {
  if (id === 1) {
    return {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      password: 'password',
    };
  }

  return {
    id: 2,
    firstName: 'Kamil',
    lastName: 'Mysliwiec',
    password: 'password2',
  };
}
```

<CalloutInfo>
  通过为控制器指定预期的返回类型，你可以充分利用 TypeScript
  的类型检查能力，确保返回的普通对象符合数据传输对象（DTO）或实体的结构。而 `plainToInstance`
  函数无法提供这种类型提示，如果普通对象与预期结构不符，可能会导致潜在的 bug。
</CalloutInfo>

## 示例

你可以在 [Nest 官方仓库的 21-serializer 示例](https://github.com/nestjs/nest/tree/master/sample/21-serializer) 中查看完整的代码示例，帮助你更好地理解相关用法。

## WebSocket 和微服务

本章主要以 HTTP 风格的应用（如 Express 或 Fastify）为例进行讲解。需要注意的是，`ClassSerializerInterceptor` 同样适用于 WebSocket 和微服务场景，无论你选择哪种传输方式，都可以正常使用。

## 了解更多

如需了解更多可用的装饰器和配置选项，建议查阅 [`class-transformer` 官方文档](https://github.com/typestack/class-transformer)。

# 自定义路由装饰器

Nest 的核心基于一种被称为**装饰器**的语言特性。装饰器在许多主流编程语言中广泛应用，但在 JavaScript 领域仍较为新颖。建议先阅读[这篇文章](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841)以深入理解装饰器的工作原理。以下是对装饰器的简要说明：

> ES2016 装饰器是一种返回函数的表达式，可接收目标对象、名称和属性描述符作为参数。你可以通过在需要装饰的内容前加上 `@` 符号来应用装饰器。装饰器既可用于类，也可用于方法或属性。

## 参数装饰器

Nest 提供了一组非常实用的参数装饰器，可与 HTTP 路由处理器配合使用。下表列出了内置装饰器及其对应的原生 Express 或 Fastify 对象：

| 装饰器                     | 对应对象                             |
| :------------------------- | :----------------------------------- |
| `@Request()`，`@Req()`     | `req`                                |
| `@Response()`，`@Res()`    | `res`                                |
| `@Next()`                  | `next`                               |
| `@Session()`               | `req.session`                        |
| `@Param(param?: string)`   | `req.params` / `req.params[param]`   |
| `@Body(param?: string)`    | `req.body` / `req.body[param]`       |
| `@Query(param?: string)`   | `req.query` / `req.query[param]`     |
| `@Headers(param?: string)` | `req.headers` / `req.headers[param]` |
| `@Ip()`                    | `req.ip`                             |
| `@HostParam()`             | `req.hosts`                          |

此外，你还可以创建自己的 **自定义装饰器**。这有什么用？

在 Node.js 生态中，开发者常常会将属性附加到请求对象上。此时，你需要在每个路由处理器中手动提取这些属性，例如：

```ts
const user = req.user
```

为了让代码更简洁、可读性更强，你可以创建一个 `@User()` 装饰器，并在所有控制器中复用：

```ts filename='user.decorator.ts'
import { createParamDecorator, ExecutionContext } from '@nestjs/common'

export const User = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest()
  return request.user
})
```

之后，你可以在控制器方法中直接使用它：

```ts
@Get()
async findOne(@User() user: UserEntity) {
  console.log(user);
}
```

## 向装饰器传递参数

当装饰器的行为依赖于特定条件时，可以通过 `data` 参数向装饰器工厂函数传递数据。常见场景之一是自定义装饰器根据 key 从请求对象中提取属性。例如，假设我们的[认证层](/security/authentication)会验证请求并将用户实体（user entity）附加到请求对象。一个已认证请求的用户实体示例如下：

```json
{
  "id": 101,
  "firstName": "Alan",
  "lastName": "Turing",
  "email": "alan@email.com",
  "roles": ["admin"]
}
```

下面我们定义一个装饰器，接收属性名作为 key，若存在则返回对应值；若不存在或 `user` 对象未创建，则返回 undefined。

```ts filename='user.decorator.ts'
import { createParamDecorator, ExecutionContext } from '@nestjs/common'

export const User = createParamDecorator((data: string, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest()
  const user = request.user

  return data ? user?.[data] : user
})
```

在控制器中，可以通过 `@User()` 装饰器访问指定属性：

```ts
@Get()
async findOne(@User('firstName') firstName: string) {
  console.log(`Hello ${firstName}`)
}
```

同一个装饰器可复用于不同 key，灵活访问用户对象的不同属性。对于结构较深或复杂的 user 对象，这种方式能让请求处理器（Route Handler）代码更简洁、可读性更高。

<CalloutInfo>
  对于 TypeScript 用户，`createParamDecorator<T>()` 是泛型方法，可显式指定类型，如 `createParamDecorator<string>((data, ctx) => ...)`。也可以在工厂函数中为参数指定类型，如 `createParamDecorator((data: string, ctx) => ...)`。若两者都省略，`data` 类型为 `any`。
</CalloutInfo>

## 配合管道使用

Nest 处理自定义参数装饰器的方式与内置装饰器（如 `@Body()`、`@Param()`、`@Query()`）一致。这意味着自定义装饰器参数同样会执行管道。你还可以直接在自定义装饰器上应用管道：

```ts
@Get()
async findOne(
  @User(new ValidationPipe({ validateCustomDecorators: true }))
  user: UserEntity,
) {
  console.log(user);
}
```

<CalloutInfo>
  需要注意，必须将 `validateCustomDecorators` 选项设置为 true。`ValidationPipe`
  默认不会校验自定义装饰器标注的参数。
</CalloutInfo>

## 装饰器的组合与复用

Nest 提供了辅助方法，可用于组合多个装饰器。例如，若希望将所有与认证相关的装饰器合并为一个装饰器，可以这样实现：

```ts filename='auth.decorator.ts'
import { applyDecorators } from '@nestjs/common'

export function Auth(...roles: Role[]) {
  return applyDecorators(
    SetMetadata('roles', roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse({ description: 'Unauthorized' })
  )
}
```

你可以像这样使用自定义的 `@Auth()` 装饰器：

```ts
@Get('users')
@Auth('admin')
findAllUsers() {}
```

这样即可一次性应用上述四个装饰器。

<CalloutInfo type="warning">
  `@nestjs/swagger` 包中的 `@ApiHideProperty()` 装饰器无法与 `applyDecorators`
  组合使用，否则会导致异常。
</CalloutInfo>

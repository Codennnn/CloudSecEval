# 自定义路由装饰器

Nest 的核心基于一种被称为 **装饰器** 的语言特性。装饰器在许多主流编程语言中都是广为人知的概念，但在 JavaScript 世界中仍然相对较新。为了更好地理解装饰器的工作原理，建议阅读[这篇文章](https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841)。下面是一个简单的定义：

> ES2016 装饰器是一种返回函数的表达式，可以接收目标对象、名称和属性描述符作为参数。你可以通过在需要装饰的内容前加上 `@` 字符来应用装饰器。装饰器既可以用于类，也可以用于方法或属性。

## 参数装饰器（Param decorators）

Nest 提供了一组非常实用的 **参数装饰器（param decorators）**，可与 HTTP 路由处理器（Route Handler）配合使用。下表列出了内置装饰器及其对应的原生 Express 或 Fastify 对象：

<table>
  <tbody>
    <tr>
      <td>`@Request(), @Req()`</td>
      <td>`req`</td>
    </tr>
    <tr>
      <td>`@Response(), @Res()`</td>
      <td>`res`</td>
    </tr>
    <tr>
      <td>`@Next()`</td>
      <td>`next`</td>
    </tr>
    <tr>
      <td>`@Session()`</td>
      <td>`req.session`</td>
    </tr>
    <tr>
      <td>`@Param(param?: string)`</td>
      <td>`req.params` / `req.params[param]`</td>
    </tr>
    <tr>
      <td>`@Body(param?: string)`</td>
      <td>`req.body` / `req.body[param]`</td>
    </tr>
    <tr>
      <td>`@Query(param?: string)`</td>
      <td>`req.query` / `req.query[param]`</td>
    </tr>
    <tr>
      <td>`@Headers(param?: string)`</td>
      <td>`req.headers` / `req.headers[param]`</td>
    </tr>
    <tr>
      <td>`@Ip()`</td>
      <td>`req.ip`</td>
    </tr>
    <tr>
      <td>`@HostParam()`</td>
      <td>`req.hosts`</td>
    </tr>
  </tbody>
</table>

此外，你还可以创建自己的 **自定义装饰器**。为什么这很有用？

在 Node.js 世界中，通常会将属性附加到 **请求对象** 上。然后你需要在每个路由处理器中手动提取这些属性，例如：

```ts
const user = req.user
```

为了让代码更加可读和直观，你可以创建一个 `@User()` 装饰器，并在所有控制器中复用它。

```ts filename='user.decorator.ts'
import { createParamDecorator, ExecutionContext } from '@nestjs/common'

export const User = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest()
  return request.user
})
```

之后，你可以在需要的地方直接使用它：

```ts
@Get()
async findOne(@User() user: UserEntity) {
  console.log(user);
}
```

## 传递数据（Passing data）

当你的装饰器行为依赖于某些条件时，可以通过 `data` 参数向装饰器工厂函数传递参数。一个常见用例是自定义装饰器根据 key 从请求对象中提取属性。例如，假设我们的[认证层](/techniques/authentication#implementing-passport-strategies)验证请求并将用户实体（user entity）附加到请求对象上。一个已认证请求的用户实体可能如下：

```json
{
  "id": 101,
  "firstName": "Alan",
  "lastName": "Turing",
  "email": "alan@email.com",
  "roles": ["admin"]
}
```

我们来定义一个装饰器，接收属性名作为 key，如果存在则返回对应的值（如果不存在或 `user` 对象未创建则返回 undefined）。

```ts filename='user.decorator.ts'
import { createParamDecorator, ExecutionContext } from '@nestjs/common'

export const User = createParamDecorator((data: string, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest()
  const user = request.user

  return data ? user?.[data] : user
})
```

在控制器中，你可以通过 `@User()` 装饰器访问特定属性：

```ts
@Get()
async findOne(@User('firstName') firstName: string) {
  console.log(`Hello ${firstName}`)
}
```

你可以为不同的 key 复用同一个装饰器，访问不同的属性。如果 `user` 对象结构较深或较复杂，这样可以让请求处理器（Route Handler）实现更简洁、可读性更强。

<CalloutInfo>
  对于 TypeScript 用户，`createParamDecorator<T>()` 是一个泛型方法。这意味着你可以显式地指定类型，例如 `createParamDecorator<string>((data, ctx) => ...)`。或者在工厂函数中为参数指定类型，如 `createParamDecorator((data: string, ctx) => ...)`。如果两者都省略，`data` 的类型将为 `any`。
</CalloutInfo>

## 配合管道（Working with pipes）

Nest 对自定义参数装饰器的处理方式与内置装饰器（如 `@Body()`、`@Param()` 和 `@Query()`）一致。这意味着自定义装饰器参数同样会执行管道。此外，你还可以直接在自定义装饰器上应用管道：

```ts
@Get()
async findOne(
  @User(new ValidationPipe({ validateCustomDecorators: true }))
  user: UserEntity,
) {
  console.log(user);
}
```

<CalloutInfo>
  需要注意的是，必须将 `validateCustomDecorators` 选项设置为 true。`ValidationPipe`
  默认不会校验自定义装饰器标注的参数。
</CalloutInfo>

## 装饰器组合（Decorator composition）

Nest 提供了一个辅助方法用于组合多个装饰器。例如，假设你想将所有与认证相关的装饰器合并为一个装饰器，可以这样实现：

```ts filename='auth.decorator.ts'
import { applyDecorators } from '@nestjs/common'

export function Auth(...roles: Role[]) {
  return applyDecorators(
    SetMetadata('roles', roles),
    UseGuards(AuthGuard, RolesGuard),
    ApiBearerAuth(),
    ApiUnauthorizedResponse({ description: 'Unauthorized' })
  )
}
```

你可以像下面这样使用自定义的 `@Auth()` 装饰器：

```ts
@Get('users')
@Auth('admin')
findAllUsers() {}
```

这样就相当于一次性应用了上述四个装饰器。

<CalloutInfo type="warning">
  `@nestjs/swagger` 包中的 `@ApiHideProperty()` 装饰器无法与 `applyDecorators`
  组合使用，否则会出现异常。
</CalloutInfo>

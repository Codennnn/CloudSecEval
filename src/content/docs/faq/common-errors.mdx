import injectorLogsImage from '/public/assets/injector_logs.png'

# 常见错误

在 NestJS 开发过程中，你可能会遇到各种错误，尤其是在刚开始学习该框架时。

## “无法解析依赖（Cannot resolve dependency）”错误

<CalloutInfo>
  建议查阅 [NestJS
  Devtools](/devtools/overview#investigating-the-cannot-resolve-dependency-error)，它可以帮助你轻松排查“无法解析依赖”的错误。
</CalloutInfo>

最常见的错误信息之一，是 Nest 无法解析提供者的依赖。其错误信息通常如下所示：

```bash
Nest can't resolve dependencies of the <provider> (?). Please make sure that the argument <unknown_token> at index [<index>] is available in the <module> context.

Potential solutions:
- Is <module> a valid NestJS module?
- If <unknown_token> is a provider, is it part of the current <module>?
- If <unknown_token> is exported from a separate @Module, is that module imported within <module>?
  @Module({
    imports: [ /* the Module containing <unknown_token> */ ]
  })
```

导致此错误最常见的原因，是提供者（`<provider>`）没有被添加到模块的 `providers` 数组中。请确保该提供者已在 `providers` 数组内，并遵循[标准的 NestJS 提供者实践](/fundamentals/custom-providers#di-fundamentals)。

另外还有一些常见的陷阱，例如，有时开发者会错误地将提供者放进 `imports` 数组。如果出现这种情况，错误信息中 `<module>` 的位置会显示为该提供者的名称。

如果你在开发中遇到此类错误，请首先检查错误信息中提到的模块及其 `providers` 数组。对于数组中的每个提供者，都应确保其所有依赖对该模块都是可见的。一种常见的情况是，“Feature 模块”和“Root 模块”声明了同一个提供者，这会导致 Nest 尝试对它进行两次实例化。通常，包含该提供者的模块应该被导入到“Root 模块”的 `imports` 数组中，而不是重复声明。

如果错误信息中的 `<unknown_token>` 是一个依赖项（`dependency`），则可能是遇到了循环文件导入。这与下文的[循环依赖](/faq/common-errors#circular-dependency-error)不同，它并非指提供者在构造函数中相互引用，而是指两个文件之间的相互导入。常见场景是：一个模块文件声明了令牌并导入了一个提供者，而该提供者反过来又从模块文件导入了该令牌。如果你使用了 barrel 文件（聚合导出），也要注意避免因此产生循环导入。

如果 `<unknown_token>` 是 `Object`，这表明你在注入时可能使用了某个类型或接口，却没有正确地为它指定提供者令牌。要解决此问题，请确保：

1.  你已导入类的引用，或使用 `@Inject()` 装饰器来指定自定义令牌。详见[自定义提供者](/fundamentals/custom-providers)。
2.  对于基于类的提供者，你导入的是具体的类，而不是仅通过 [`import type ...`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) 语法导入其类型。

此外，还应确保没有将提供者注入其自身，因为 NestJS 不支持自我注入。如果发生这种情况，`<unknown_token>` 很可能与 `<provider>` 相同。

如果你在**多包仓库结构**下开发，遇到类似的错误，但 `<unknown_token>` 是核心提供者 `ModuleRef`，其错误信息如下：

```bash
Nest can't resolve dependencies of the <provider> (?).
Please make sure that the argument ModuleRef at index [<index>] is available in the <module> context.
...
```

这通常是因为你的项目加载了两个不同的 `@nestjs/core` Node 模块，例如：

```
.
├── package.json
├── apps
│   └── api
│       └── node_modules
│           └── @nestjs/bull
│               └── node_modules
│                   └── @nestjs/core
└── node_modules
    ├── (other packages)
    └── @nestjs/core
```

解决方案如下：

- 对于 **Yarn** 工作空间，可以使用 [nohoist 功能](https://classic.yarnpkg.com/blog/2018/02/15/nohoist)防止 `@nestjs/core` 被提升（hoist）。
- 对于 **pnpm** 工作空间，在其他模块中将 `@nestjs/core` 设置为 `peerDependencies`，并在应用的 `package.json` 中添加 `"dependenciesMeta": { "other-module-name": { "injected": true } }`。详见 [dependenciesMeta.injected](https://pnpm.io/package_json#dependenciesmetainjected)。

## “循环依赖（Circular dependency）”错误

在开发中，有时很难完全避免[循环依赖](/fundamentals/circular-dependency)。此时，你需要采取一些措施来帮助 Nest 正确解析他们。由循环依赖引发的错误通常如下：

```bash
Nest cannot create the <module> instance.
The module at index [<index>] of the <module> "imports" array is undefined.

Potential causes:
- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency
- The module at index [<index>] is of type "undefined". Check your import statements and the type of the module.

Scope [<module_import_chain>]
# example chain AppModule -> FooModule
```

循环依赖可能源于提供者之间的相互依赖，也可能源于 TypeScript 文件之间对常量的循环导入。对于后者，一种常见的场景是从模块文件导出常量，然后在服务文件中导入它，这可能导致循环。建议将常量提取到独立的文件中。对于提供者之间的循环依赖，请参考循环依赖指南，确保在模块和提供者层面都使用 `forwardRef`。

## 依赖错误调试

除了手动检查依赖关系，从 Nest 8.1.0 开始，你还可以将 `NEST_DEBUG` 环境变量设置为任意真值字符串，从而在 Nest 解析依赖时获取额外的日志信息。

<DocImage src={injectorLogsImage} />

在上图中，黄色字符串代表注入依赖的宿主类，蓝色字符串代表依赖项的名称或注入令牌，而紫色字符串则指明了正在哪个模块中查找该依赖。这些信息通常能帮助你追踪依赖解析过程，从而定位问题的根源。

## “File change detected” 无限循环

Windows 用户在使用 TypeScript 4.9 及以上版本时，可能会遇到此问题。
当你以 watch 模式运行应用（如 `npm run start:dev`），会看到如下日志不断循环：

```bash
XX:XX:XX AM - File change detected. Starting incremental compilation...
XX:XX:XX AM - Found 0 errors. Watching for file changes.
```

使用 NestJS 命令行工具（Nest CLI）以 watch 模式启动应用时，其底层会调用 `tsc --watch`。自 TypeScript 4.9 起，其[文件变更检测策略](https://devblogs.microsoft.com/typescript/announcing-typescript-4-9/#file-watching-now-uses-file-system-events)发生了变化，这很可能是导致此问题的原因。

要解决此问题，需要在 `tsconfig.json` 文件中，为 `compilerOptions` 添加 `watchOptions` 设置：

```json
  "watchOptions": {
    "watchFile": "fixedPollingInterval"
  }
```

此配置会使 TypeScript 采用轮询方式来检测文件变更，而非其默认的文件系统事件方式。在某些机器上，后者可能会引发问题。
你可以在 [TypeScript 官方文档](https://www.typescriptlang.org/tsconfig#watch-watchDirectory)中了解关于 `watchFile` 选项的更多信息。

# Serverless（无服务器架构）

无服务器计算（Serverless computing）是一种云计算执行模型，云服务商会根据需求动态分配计算资源并管理服务器。当你的应用没有流量时，就不会占用任何计算资源，而你只需为应用实际消耗的资源付费。（[来源](https://en.wikipedia.org/wiki/Serverless_computing)）。

采用**无服务器架构（Serverless Architecture）**，开发者可以专注于编写独立的函数，而无需关心底层。AWS Lambda、Google Cloud Functions 和 Microsoft Azure Functions 等服务会为你处理好所有物理硬件、虚拟机操作系统和 Web 服务器软件的管理工作。

<CalloutInfo>
  <div>
    本章不讨论无服务器函数的优缺点，也不会深入探讨特定云厂商的实现细节。
  </div>
</CalloutInfo>

## 冷启动

冷启动（Cold Start）指的是你的代码在闲置一段时间后首次被调用执行。根据云厂商的不同，冷启动过程可能包括下载代码、启动运行时（Bootstrap）等多个步骤，最终才会执行你的代码。

这个过程会因编程语言、依赖包数量等多种因素而产生明显的延迟。

冷启动问题不容忽视。尽管有些因素我们无法控制，但仍然可以通过一些优化手段来尽可能缩短冷启动时间。

虽然 Nest 通常被看作是为复杂企业级应用设计的全功能框架，但它同样适用于更轻量的应用场景，例如 worker、定时任务（CRON job）、命令行工具（CLI）甚至是无服务器函数。借助[独立应用](/standalone-applications)特性，你在这些场景下依然可以充分利用 Nest 强大的依赖注入系统。

## 基准测试

为了更好地理解在无服务器函数（Serverless Function）场景下，使用 Nest 和其他流行库（如 `express`）的性能开销，我们测试了 Node 运行时启动以下不同脚本所需的时间：

```ts
// #1 Express
import * as express from 'express'

async function bootstrap() {
  const app = express()
  app.get('/', (req, res) => res.send('Hello world!'))
  await new Promise<void>((resolve) => app.listen(3000, resolve))
}
bootstrap()

// #2 Nest（基于 @nestjs/platform-express）
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { logger: ['error'] })
  await app.listen(process.env.PORT ?? 3000)
}
bootstrap()

// #3 Nest 作为独立应用（无 HTTP 服务器）
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { AppService } from './app.service'

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule, {
    logger: ['error'],
  })
  console.log(app.get(AppService).getHello())
}
bootstrap()

// #4 原生 Node.js 脚本
async function bootstrap() {
  console.log('Hello world!')
}
bootstrap()
```

上述所有脚本均使用 `tsc`（TypeScript 编译器）进行编译，因此代码未经过打包（未使用 `webpack`）。

| 框架                                    | 启动时间                |
| --------------------------------------- | ----------------------- |
| Express                                 | 0.0079 秒（7.9 毫秒）   |
| Nest（基于 `@nestjs/platform-express`） | 0.1974 秒（197.4 毫秒） |
| Nest（独立应用）                        | 0.1117 秒（111.7 毫秒） |
| 原生 Node.js 脚本                       | 0.0071 秒（7.1 毫秒）   |

<CalloutInfo title="说明">
  机器配置：MacBook Pro Mid 2014，2.5 GHz 四核 Intel Core i7，16 GB 1600 MHz
  DDR3，SSD。
</CalloutInfo>

接下来，我们使用 `webpack` 将所有脚本打包后再进行一次基准测试。（如果你安装了 [Nest CLI](/cli/overview)，可以通过 `nest build --webpack` 命令将应用打包成一个独立的 JavaScript 文件）。我们没有使用 Nest CLI 的默认 `webpack` 配置，而是通过以下配置确保所有依赖项（`node_modules`）都被打包到最终文件中：

```js
module.exports = (options, webpack) => {
  const lazyImports = [
    '@nestjs/microservices/microservices-module',
    '@nestjs/websockets/socket-module',
  ]

  return {
    ...options,
    externals: [],
    plugins: [
      ...options.plugins,
      new webpack.IgnorePlugin({
        checkResource(resource) {
          if (lazyImports.includes(resource)) {
            try {
              require.resolve(resource)
            } catch (err) {
              return true
            }
          }
          return false
        },
      }),
    ],
  }
}
```

<CalloutInfo>
  如需让 Nest CLI 使用此配置，请在项目根目录下新建 `webpack.config.js` 文件。
</CalloutInfo>

采用上述配置后，得到如下测试结果：

| 框架                                    | 启动时间               |
| --------------------------------------- | ---------------------- |
| Express                                 | 0.0068 秒（6.8 毫秒）  |
| Nest（基于 `@nestjs/platform-express`） | 0.0815 秒（81.5 毫秒） |
| Nest（独立应用）                        | 0.0319 秒（31.9 毫秒） |
| 原生 Node.js 脚本                       | 0.0066 秒（6.6 毫秒）  |

<CalloutInfo title="说明">
  机器配置：MacBook Pro Mid 2014，2.5 GHz 四核 Intel Core i7，16 GB 1600 MHz
  DDR3，SSD。
</CalloutInfo>

<CalloutInfo>
  <div>
    你还可以通过进一步的代码压缩和优化（如使用 `webpack` 插件等）来提升性能。
  </div>
</CalloutInfo>

可以看到，编译和打包方式对应用的整体启动时间有显著影响。通过 `webpack` 打包后，一个独立的 Nest 应用（包含一个模块、一个控制器和一个服务）的平均启动时间可以降至约 32 毫秒，而一个标准的、基于 Express 的 NestJS 应用约为 81.5 毫秒。

对于一个更复杂的 Nest 应用——例如包含 10 个资源（通过 `$ nest g resource` 命令生成，即 10 个模块、10 个控制器、10 个服务、20 个 DTO 类、50 个 HTTP 端点以及 `AppModule`）——在相同的测试环境下，其总启动时间约为 0.1298 秒（129.8 毫秒）。当然，将一个庞大的单体应用作为单个无服务器函数运行通常是不切实际的，所以你可以将这个基准测试看作一个参考，了解应用规模增长对启动时间的影响。

## 运行时优化

以上我们讨论了编译时优化。这些优化与你如何定义提供者、加载模块无关。然而，当应用规模增长时，后者（即运行时机制）对启动性能的影响将变得至关重要。

举个例子，假设你有一个数据库连接被定义为[异步提供者](/fundamentals/async-providers)。异步提供者旨在延迟应用启动，直到一个或多个异步任务完成。
这意味着，如果你的无服务器函数在启动时平均需要 2 秒来建立数据库连接，那么在发生冷启动时，你的函数需要额外等待 2 秒才能响应请求。这是因为应用必须等待数据库连接就绪。

如你所见，在**无服务器环境**下，组织提供者的方式与常规应用有所不同，因为启动时间至关重要。
举个例子，如果你只在某些场景下才需要使用 Redis 缓存，就不应该将 Redis 连接设置为异步提供者。因为即使当前函数调用并不需要缓存，它也会拖慢整个应用的启动速度。

此外，你还可以使用 `LazyModuleLoader` 类（详情见[此章](/fundamentals/lazy-loading-modules)）来懒加载模块。缓存就是一个很好的应用场景。
假设你的应用有一个 `CacheModule`，它负责连接 Redis 并导出了一个用于操作缓存的 `CacheService`。如果并非所有函数调用都需要缓存功能，你就可以按需懒加载这个模块。这样一来，在那些不需要缓存的冷启动场景下，启动速度就会更快。

```ts
if (request.method === RequestMethod[RequestMethod.GET]) {
  const { CacheModule } = await import('./cache.module')
  const moduleRef = await this.lazyModuleLoader.load(() => CacheModule)

  const { CacheService } = await import('./cache.service')
  const cacheService = moduleRef.get(CacheService)

  return cacheService.get(ENDPOINT_KEY)
}
```

另一个适合懒加载的典型场景是 Webhook 或 Worker。他们通常会根据输入参数等特定条件执行不同的逻辑。
在这种情况下，你可以在请求处理函数中加入判断逻辑，只在需要时才加载相应的模块，从而避免加载非必需模块带来的开销。

```ts
if (workerType === WorkerType.A) {
  const { WorkerAModule } = await import('./worker-a.module')
  const moduleRef = await this.lazyModuleLoader.load(() => WorkerAModule)
  // ...
} else if (workerType === WorkerType.B) {
  const { WorkerBModule } = await import('./worker-b.module')
  const moduleRef = await this.lazyModuleLoader.load(() => WorkerBModule)
  // ...
}
```

## 集成示例

入口文件（通常是 `main.ts`）的写法取决于多个因素，因此**没有一个万能模板**。例如，为不同云厂商（如 AWS、Azure、GCP）部署函数时，入口文件的写法就会不同。此外，你的应用结构也会受到目标功能的影响：你是要运行一个包含多个路由的完整 HTTP 应用，还是只想执行一个独立的函数？（例如，在"一个函数一个端点"的模式下，你可能会使用 `NestFactory.createApplicationContext`，而不是启动一个完整的 HTTP 服务器）。

为了演示，下面我们将 Nest（使用 `@nestjs/platform-express`，它会启动完整的 HTTP 路由功能）与 [Serverless Framework](https://www.serverless.com/) 进行集成（目标平台为 AWS Lambda）。再次强调，你的具体实现会因云厂商和其他因素而异。

首先，安装所需依赖包：

```bash
$ npm i @codegenie/serverless-express aws-lambda
$ npm i -D @types/aws-lambda serverless-offline
```

<CalloutInfo>
  我们安装了 `serverless-offline` 插件来模拟本地的 AWS Lambda 和 API Gateway
  环境，这可以大大加快开发和调试速度。
</CalloutInfo>

安装完成后，创建 `serverless.yml` 文件，用于配置 Serverless 框架：

```yaml
service: serverless-example

plugins:
  - serverless-offline

provider:
  name: aws
  runtime: nodejs14.x

functions:
  main:
    handler: dist/main.handler
    events:
      - http:
          method: ANY
          path: /
      - http:
          method: ANY
          path: '{proxy+}'
```

<CalloutInfo>
  想了解更多关于 Serverless
  框架的信息，请访问[官方文档](https://www.serverless.com/framework/docs/)。
</CalloutInfo>

接下来，打开 `main.ts`，用以下代码更新你的应用启动逻辑：

```ts
import { NestFactory } from '@nestjs/core'
import serverlessExpress from '@codegenie/serverless-express'
import { Callback, Context, Handler } from 'aws-lambda'
import { AppModule } from './app.module'

let server: Handler

async function bootstrap(): Promise<Handler> {
  const app = await NestFactory.create(AppModule)
  await app.init()

  const expressApp = app.getHttpAdapter().getInstance()
  return serverlessExpress({ app: expressApp })
}

export const handler: Handler = async (
  event: any,
  context: Context,
  callback: Callback
) => {
  server = server ?? (await bootstrap())
  return server(event, context, callback)
}
```

<CalloutInfo>
  如果你需要创建多个无服务器函数并希望他们共享模块，建议采用 [CLI 的 Monorepo
  模式](/cli/monorepo#monorepo-mode)。
</CalloutInfo>

<CalloutInfo type="warning">
  如果你使用了 `@nestjs/swagger`
  包，在无服务器函数场景下还需额外配置，才能正常工作。详情请参考此[讨论帖](https://github.com/nestjs/swagger/issues/199)。
</CalloutInfo>

然后，打开 `tsconfig.json` 文件，确保启用了 `esModuleInterop` 选项，以便正确加载 `@codegenie/serverless-express` 包。

```json
{
  "compilerOptions": {
    ...
    "esModuleInterop": true
  }
}
```

现在可以构建应用（使用 `nest build` 或 `tsc`），并通过 `serverless` CLI 在本地启动 Lambda 函数：

```bash
$ npm run build
$ npx serverless offline
```

应用启动后，打开浏览器访问 `http://localhost:3000/dev/[ANY_ROUTE]`（其中 `[ANY_ROUTE]` 为应用中注册的任意端点）。

我们之前提到，使用 `webpack` 打包应用会显著改善启动时间。然而，为了让这个例子正常工作，你需要在 `webpack.config.js` 中添加一些额外配置。通常需要将 `output.libraryTarget` 属性设为 `commonjs2`，以确保 `handler` 函数能被正确导出。

```js
return {
  ...options,
  externals: [],
  output: {
    ...options.output,
    libraryTarget: 'commonjs2',
  },
  // ... 其他配置项
}
```

完成上述配置后，可以使用 `$ nest build --webpack` 编译函数代码（然后用 `$ npx serverless offline` 进行本地测试）。

此外，我们还**推荐**（但非必需，因为它会拖慢构建速度）安装 `terser-webpack-plugin` 包并覆盖其默认配置，以便在生产环境压缩代码时保留类名。否则，如果你在应用中使用了 `class-validator`，可能会遇到意外行为。

```js
const TerserPlugin = require('terser-webpack-plugin')

return {
  ...options,
  externals: [],
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          keep_classnames: true,
        },
      }),
    ],
  },
  output: {
    ...options.output,
    libraryTarget: 'commonjs2',
  },
  // ... 其他配置项
}
```

## 使用独立应用功能

另外，如果你希望函数保持极其轻量，并且不需要任何 HTTP 相关的功能（如路由、守卫、拦截器、管道等），你可以直接使用 `NestFactory.createApplicationContext`，而不是启动一个完整的 HTTP 服务器（底层为 `express`），示例如下：

```ts filename='main.ts'
import { HttpStatus } from '@nestjs/common'
import { NestFactory } from '@nestjs/core'
import { Callback, Context, Handler } from 'aws-lambda'
import { AppModule } from './app.module'
import { AppService } from './app.service'

export const handler: Handler = async (
  event: any,
  context: Context,
  callback: Callback
) => {
  const appContext = await NestFactory.createApplicationContext(AppModule)
  const appService = appContext.get(AppService)

  return {
    body: appService.getHello(),
    statusCode: HttpStatus.OK,
  }
}
```

<CalloutInfo>
  请注意，`NestFactory.createApplicationContext`
  不会为控制器方法应用增强器（如守卫、拦截器等）。如需此功能，必须使用
  `NestFactory.create` 方法。
</CalloutInfo>

你也可以将 `event` 对象传递给某个服务（例如 `EventsService`），让它根据你的业务逻辑处理输入并返回结果。

```ts
export const handler: Handler = async (
  event: any,
  context: Context,
  callback: Callback
) => {
  const appContext = await NestFactory.createApplicationContext(AppModule)
  const eventsService = appContext.get(EventsService)
  return eventsService.process(event)
}
```

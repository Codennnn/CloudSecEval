import moduleImage from '/public/assets/Modules_1.png'
import sharedModuleImage from '/public/assets/Shared_Module_1.png'

# 模块

模块（Module）是一个通过 `@Module()` 装饰器定义的类。该装饰器提供的元数据，帮助 Nest 高效地组织和管理应用结构。

<DocImage src={moduleImage} alt="模块结构图" />

每个 Nest 应用至少包含一个模块，即**根模块（root module）**，它是 Nest 构建应用图（application graph）的起点。应用图用于描述模块与提供者之间的关系和依赖。虽然小型应用可能只有根模块，但在实际开发中，通常会有多个模块。模块被**强烈推荐**用于高效组织各类组件。对于大多数应用，你很可能会有多个模块，每个模块都封装了一组紧密相关的功能。

`@Module()` 装饰器接收一个对象参数，该对象包含用于描述模块的属性：

| 属性          | 描述                                                                                                              |
| ------------- | ----------------------------------------------------------------------------------------------------------------- |
| `providers`   | 由 Nest 注入器实例化的提供者，至少可在本模块内共享                                                                |
| `controllers` | 在本模块中定义并需要被实例化的控制器（controller）                                                                |
| `imports`     | 导入的模块列表，这些模块导出了本模块所需的提供者                                                                  |
| `exports`     | 本模块提供并希望在导入本模块的其他模块中可用的 `providers` 子集。你可以直接使用提供者本身或其令牌（`provide` 值） |

模块默认封装其提供者。这意味着你只能注入当前模块内的提供者，或从其他已导入模块中显式导出的提供者。模块导出的提供者，本质上构成了该模块的公共接口（API）。

## 功能模块

在我们的示例中，`CatsController` 和 `CatsService` 紧密相关，服务于同一应用领域。将他们归为一个功能模块（feature module）是合理的。功能模块用于组织与特定功能相关的代码，有助于保持清晰的边界和更好的组织结构。随着应用或团队规模的增长，这一点尤为重要，同时也符合 [SOLID](https://en.wikipedia.org/wiki/SOLID) 原则。

接下来，我们将创建 `CatsModule`，演示如何将控制器和服务分组。

```ts filename='cats/cats.module.ts'
import { Module } from '@nestjs/common'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
```

<CalloutInfo>
  <div>你可以通过 CLI 执行 `$ nest g module cats` 命令来创建模块。</div>
</CalloutInfo>

如上，我们在 `cats.module.ts` 文件中定义了 `CatsModule`，并将与该模块相关的所有内容移至 `cats` 目录。最后一步是将该模块导入根模块（即 `app.module.ts` 文件中定义的 `AppModule`）。

```ts filename='app.module.ts'
import { Module } from '@nestjs/common'
import { CatsModule } from './cats/cats.module'

@Module({
  imports: [CatsModule],
})
export class AppModule {}
```

现在我们的目录结构如下：

<FileTree
  data={[
    {
      name: 'src',
      children: [
        {
          name: 'cats',
          children: [
            { name: 'dto', children: [{ name: 'create-cat.dto.ts' }] },
            { name: 'interfaces', children: [{ name: 'cat.interface.ts' }] },
            { name: 'cats.controller.ts' },
            { name: 'cats.module.ts' },
            { name: 'cats.service.ts' },
          ],
        },
        { name: 'app.module.ts' },
        { name: 'main.ts' },
      ],
    },
  ]}
/>

## 共享模块与服务复用

在 Nest 中，模块默认是 **单例（singleton）**，这意味着你可以轻松地在多个模块之间共享同一个提供者实例。

<DocImage src={sharedModuleImage} alt="共享模块结构图" />

每个模块天生就是 **共享模块**，一旦创建，即可被任何其他模块复用。例如，如果我们希望在多个模块之间共享 `CatsService` 的实例，需要先将 `CatsService` 添加到模块的 `exports` 数组中进行导出，如下所示：

```ts filename='cats.module.ts'
import { Module } from '@nestjs/common'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService], // 导出 CatsService，供其他模块复用
})
export class CatsModule {}
```

这样，任何导入 `CatsModule` 的模块都可以访问 `CatsService`，并且所有导入该模块的地方都会共享同一个 `CatsService` 实例。

如果我们在每个需要的模块中分别注册 `CatsService`，虽然功能上没有问题，但每个模块都会获得各自独立的 `CatsService` 实例。这不仅会增加内存消耗（因为会创建多个相同服务的实例），还可能导致服务内部状态不一致等意外行为。

通过将 `CatsService` 封装在模块（如 `CatsModule`）中并导出，我们确保所有导入 `CatsModule` 的模块都复用同一个 `CatsService` 实例。这样不仅节省了内存，还让行为更加可预测，因为所有模块共享同一个实例，便于统一管理共享状态或资源。

这正是 NestJS 框架模块化和依赖注入机制的关键优势之一 —— 让服务能够在整个应用中高效、安全地共享。

## 模块的再导出

如前所述，模块不仅可以导出自身的提供者，还可以再导出其导入的模块。例如，`CommonModule` 被导入到 `CoreModule`，并同时被导出。这样，其他导入 `CoreModule` 的模块也能直接使用 `CommonModule`。

```ts
@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}
```

## 模块中的依赖注入

你也可以在模块类本身注入提供者（例如用于配置）：

```ts filename='cats.module.ts'
import { Module } from '@nestjs/common'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {
  constructor(private catsService: CatsService) {}
}
```

```js hideInDoc filename='cats.module.js'
import { Module, Dependencies } from '@nestjs/common'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
@Dependencies(CatsService)
export class CatsModule {
  constructor(catsService) {
    this.catsService = catsService
  }
}
```

需要注意的是，模块类本身不能作为提供者被注入，否则会导致[循环依赖](/fundamentals/circular-dependency)问题。

## 全局模块用法

如果你经常需要在多个地方导入同一组模块，可能会觉得操作繁琐。与 [Angular](https://angular.dev) 不同，Nest 的 `providers` 默认不会全局注册，而是被封装在各自的模块作用域内。也就是说，只有在导入了某个模块后，才能直接使用其提供者，这有助于避免全局污染和意外依赖。

当你希望某些提供者（如工具类、数据库连接等）在全局范围内可用时，可以使用 `@Global()` 装饰器将模块声明为**全局模块（global module）**。

```ts
import { Module, Global } from '@nestjs/common'
import { CatsController } from './cats.controller'
import { CatsService } from './cats.service'

@Global()
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
```

`@Global()` 装饰器会将模块设为全局作用域。全局模块一般只需在根模块或核心模块中注册一次。上述示例中，`CatsService` 提供者将变为全局可用，其他需要注入该服务的模块无需在 `imports` 数组中显式导入 `CatsModule`。

<CalloutInfo>
  通常不建议将所有内容都设为全局。虽然全局模块能减少样板代码，但更推荐通过 `imports`
  数组有选择地暴露模块 API，这样结构更清晰、可维护性更高，也能避免不相关模块间产生不必要的耦合。
</CalloutInfo>

## 动态模块配置

Nest 中的动态模块允许你在运行时灵活配置模块内容。这对于需要根据选项或配置动态创建提供者的场景非常有用。下面简要介绍动态模块的基本用法。

```ts
import { Module, DynamicModule } from '@nestjs/common'
import { createDatabaseProviders } from './database.providers'
import { Connection } from './connection.provider'

@Module({
  providers: [Connection],
  exports: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities)
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    }
  }
}
```

```js hideInDoc
import { Module } from '@nestjs/common'
import { createDatabaseProviders } from './database.providers'
import { Connection } from './connection.provider'

@Module({
  providers: [Connection],
  exports: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options) {
    const providers = createDatabaseProviders(options, entities)
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    }
  }
}
```

<CalloutInfo>

`forRoot()` 方法既可以同步返回动态模块，也可以返回 `Promise` 实现异步配置。

</CalloutInfo>

在上述示例中，模块通过 `@Module()` 装饰器静态声明了 `Connection` 提供者。同时，`forRoot()` 方法根据传入的 `entities` 和 `options` 动态生成一组提供者（如仓储 repository）。需要注意，动态模块返回的属性会扩展基础模块的元数据，而不是覆盖。因此，静态声明的 `Connection` 和动态生成的提供者都会被导出。

如果你希望将动态模块注册为全局模块，只需在返回对象中添加 `global: true` 属性：

```ts
{
  global: true,
  module: DatabaseModule,
  providers: providers,
  exports: providers,
}
```

<CalloutInfo type="warning">
  <div>
    如前所述，不建议将所有内容都设为全局模块。虽然全局模块可以减少样板代码，但更推荐按需导入，保持结构清晰、可维护，避免不必要的耦合。
  </div>
</CalloutInfo>

你可以像下面这样导入和配置 `DatabaseModule`：

```ts
import { Module } from '@nestjs/common'
import { DatabaseModule } from './database/database.module'
import { User } from './users/entities/user.entity'

@Module({
  imports: [DatabaseModule.forRoot([User])],
})
export class AppModule {}
```

如果需要将动态模块再导出，可以在 `exports` 数组中直接写模块本身，无需调用 `forRoot()`：

```ts
import { Module } from '@nestjs/common'
import { DatabaseModule } from './database/database.module'
import { User } from './users/entities/user.entity'

@Module({
  imports: [DatabaseModule.forRoot([User])],
  exports: [DatabaseModule],
})
export class AppModule {}
```

有关动态模块的更多内容，请参阅[动态模块](/fundamentals/dynamic-modules)章节，并参考[官方示例](https://github.com/nestjs/nest/tree/master/sample/25-dynamic-modules)。

<CalloutInfo>
  你还可以在[本章节](/fundamentals/dynamic-modules#configurable-module-builder)了解如何使用
  `ConfigurableModuleBuilder` 构建高度可定制的动态模块。
</CalloutInfo>

# 路由模块

<CalloutInfo>本章内容仅适用于基于 HTTP 的应用。</CalloutInfo>

在构建如 RESTful API 等基于 HTTP 的应用时，路由的完整路径由两部分组成：控制器上的 `@Controller()` 装饰器所定义的路径前缀（可选），以及方法装饰器（如 `@Get('users')`）中指定的路径。你可以在[控制器章节](/controllers#路由)了解更多详细内容。

此外，Nest 还支持为整个应用配置[全局路由前缀](/faq/global-prefix)，或启用[路由版本控制](/techniques/versioning)功能。

在某些场景下，我们希望为模块中所有控制器统一添加一个路径前缀。这在组织模块路由结构、保持命名一致性方面尤其有用。举例来说，假设你的应用中有一组服务于「仪表盘（Dashboard）」功能的端点。为了避免在每个相关控制器中手动添加 `/dashboard` 前缀，你可以使用 `RouterModule` 模块来统一配置，如下所示：

```ts filename='app.module.ts'
import { RouterModule } from '@nestjs/core'

@Module({
  imports: [
    DashboardModule,
    RouterModule.register([
      {
        path: 'dashboard',
        module: DashboardModule,
      },
    ]),
  ],
})
export class AppModule {}
```

`RouterModule` 还支持定义嵌套路由。这意味着你可以通过设置模块的 `children` 属性，将子模块注册到某个父模块下，并自动继承父模块的路径前缀。

例如，下面的示例中，我们将 `AdminModule` 作为父模块，分别挂载了 `DashboardModule` 和 `MetricsModule` 作为其子模块：

```ts
@Module({
  imports: [
    AdminModule,
    DashboardModule,
    MetricsModule,
    RouterModule.register([
      {
        path: 'admin',
        module: AdminModule,
        children: [
          {
            path: 'dashboard',
            module: DashboardModule,
          },
          {
            path: 'metrics',
            module: MetricsModule,
          },
        ],
      },
    ])
  ],
})
```

<CalloutInfo>
  建议谨慎使用该功能，层级过深的路由结构可能会导致代码难以维护。
</CalloutInfo>

在上述示例中，`DashboardModule` 中注册的所有控制器都会自动带上 `/admin/dashboard` 路径前缀；同样，`MetricsModule` 中的控制器也会统一应用 `/admin/metrics` 前缀。这是因为模块路径会从顶层父模块开始，递归拼接其所有子模块的路径配置。

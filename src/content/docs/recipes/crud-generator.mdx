# CRUD 生成器（仅限 TypeScript）

在项目开发过程中，我们经常需要为应用添加新功能，而这通常意味着要定义新的资源。每创建一个新资源，我们都得重复一系列繁琐的操作。

## 简介

设想一个典型场景：你需要为 **User** 和 **Product** 这两个实体暴露 CRUD（增删改查）接口。按照最佳实践，你需要为每个实体执行以下操作：

- 生成一个模块（`nest g mo`），用于组织代码并建立清晰的边界。
- 生成一个控制器（`nest g co`），用于定义 CRUD 路由（对于 GraphQL 应用，即查询和变更）。
- 生成一个服务（`nest g s`），用于实现并隔离业务逻辑。
- 生成一个实体类或接口，用于描述资源的数据结构。
- 生成数据传输对象（DTO）（或 GraphQL 应用的输入类型），用于定义数据在网络中的传输格式。

这确实是很多步骤！

为了简化这个重复流程，[Nest 命令行工具 (Nest CLI)](/cli/overview) 提供了一个生成器（schematic）。它可以自动生成所有模板代码，从而避免手动操作，并大大提升开发体验。

<CalloutInfo>
  这款生成器支持创建 **HTTP** 控制器、**微服务**控制器、**GraphQL** 解析器（支持 code first 和
  schema first 模式）以及 **WebSocket** 网关。
</CalloutInfo>

## 生成新资源

要创建新资源，只需在项目根目录下运行以下命令：

```bash
$ nest g resource
```

`nest g resource` 命令不仅会生成所有核心的 Nest 组件（如模块、服务、控制器），还会一并创建实体类、DTO 类以及测试（`.spec`）文件。

下面是针对 RESTful API 生成的控制器文件示例：

```ts
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto)
  }

  @Get()
  findAll() {
    return this.usersService.findAll()
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id)
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(+id, updateUserDto)
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id)
  }
}
```

此外，生成器还会为所有 CRUD 端点创建占位符方法，包括 RESTful API 的路由、GraphQL 的查询与变更、以及微服务和 WebSocket 网关的消息处理器。这样，你就不必再手动编写这些基础代码了。

<CalloutInfo type="warning">
  生成的服务类默认**不依赖于任何特定的 ORM
  或数据源**，这使得该工具足够通用，能适应不同类型的项目。所有方法都只包含占位实现，方便你根据项目的实际数据源来填充业务逻辑。
</CalloutInfo>

同样，如果你希望为 GraphQL 应用生成解析器，只需在提示中选择 `GraphQL (code first)` 或 `GraphQL (schema first)` 作为传输层（Transport Layer）。

这样，NestJS 就会为你生成解析器类，而不是 RESTful API 控制器：

```bash
$ nest g resource users

> ? 你使用哪种传输层？GraphQL（code first）
> ? 是否需要生成 CRUD 入口？是
> CREATE src/users/users.module.ts (224 bytes)
> CREATE src/users/users.resolver.spec.ts (525 bytes)
> CREATE src/users/users.resolver.ts (1109 bytes)
> CREATE src/users/users.service.spec.ts (453 bytes)
> CREATE src/users/users.service.ts (625 bytes)
> CREATE src/users/dto/create-user.input.ts (195 bytes)
> CREATE src/users/dto/update-user.input.ts (281 bytes)
> CREATE src/users/entities/user.entity.ts (187 bytes)
> UPDATE src/app.module.ts (312 bytes)
```

<CalloutInfo>
  如果不想生成测试文件，可以添加 `--no-spec` 参数，例如：`nest g resource users --no-spec`。
</CalloutInfo>

可以看到，所有模板代码（包括变更和查询）都已生成，并且各部分之间的依赖关系也已自动注入。例如，`UsersResolver` 中已经引入了 `UsersService`、`User` 实体以及 DTO。

```ts
import { Resolver, Query, Mutation, Args, Int } from '@nestjs/graphql'
import { UsersService } from './users.service'
import { User } from './entities/user.entity'
import { CreateUserInput } from './dto/create-user.input'
import { UpdateUserInput } from './dto/update-user.input'

@Resolver(() => User)
export class UsersResolver {
  constructor(private readonly usersService: UsersService) {}

  @Mutation(() => User)
  createUser(@Args('createUserInput') createUserInput: CreateUserInput) {
    return this.usersService.create(createUserInput)
  }

  @Query(() => [User], { name: 'users' })
  findAll() {
    return this.usersService.findAll()
  }

  @Query(() => User, { name: 'user' })
  findOne(@Args('id', { type: () => Int }) id: number) {
    return this.usersService.findOne(id)
  }

  @Mutation(() => User)
  updateUser(@Args('updateUserInput') updateUserInput: UpdateUserInput) {
    return this.usersService.update(updateUserInput.id, updateUserInput)
  }

  @Mutation(() => User)
  removeUser(@Args('id', { type: () => Int }) id: number) {
    return this.usersService.remove(id)
  }
}
```

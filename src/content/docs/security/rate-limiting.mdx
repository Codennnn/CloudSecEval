# 请求频率限制

请求频率限制（Rate Limiting）是一种保护应用免受暴力破解等攻击的常用技术。要开始使用，请先安装 `@nestjs/throttler` 包。

```bash
$ npm i --save @nestjs/throttler
```

安装完成后，可以像配置其他 Nest 包一样，使用 `forRoot` 或 `forRootAsync` 方法来配置 `ThrottlerModule` (限流模块)。

```ts filename='app.module.ts'
@Module({
  imports: [
    ThrottlerModule.forRoot({
      throttlers: [
        {
          ttl: 60000,
          limit: 10,
        },
      ],
    }),
  ],
})
export class AppModule {}
```

上述配置为所有受 `ThrottlerGuard` 保护的路由设置了全局限流规则：`ttl` (Time To Live，单位为毫秒) 和 `limit` (在 `ttl` 时间窗口内允许的最大请求数)。

引入模块后，你可以根据需要绑定 `ThrottlerGuard` (限流守卫)。与[守卫 (Guard)](/guards)类似，任何绑定方式都适用。若要全局启用，可将其作为 `provider` 添加到任意模块中：

```ts
{
  provide: APP_GUARD,
  useClass: ThrottlerGuard
}
```

## 多重限流定义

有时，你可能需要设置多套限流规则，例如：每秒最多 3 次请求，每 10 秒最多 20 次，以及每分钟最多 100 次。为此，你可以在配置数组中为每套规则指定 `name`，然后通过 `@SkipThrottle()` 和 `@Throttle()` 装饰器按名称引用，从而实现灵活的策略切换。

```ts filename='app.module.ts'
@Module({
  imports: [
    ThrottlerModule.forRoot([
      {
        name: 'short',
        ttl: 1000,
        limit: 3,
      },
      {
        name: 'medium',
        ttl: 10000,
        limit: 20,
      },
      {
        name: 'long',
        ttl: 60000,
        limit: 100,
      },
    ]),
  ],
})
export class AppModule {}
```

## 个性化定制

在某些场景下，你可能需要将守卫全局绑定，但又希望对特定接口禁用限流。此时，可以使用 `@SkipThrottle()` 装饰器，使整个控制器类或单个路由跳过限流检查。`@SkipThrottle()` 还可以接收一个对象参数 (键为限流器名称，值为布尔值)，这在你需要排除控制器中的大部分路由，或根据名称跳过特定限流规则时非常有用。若不带参数使用，其效果等同于 `{{ '{' }} default: true {{ '}' }}`。

```ts
@SkipThrottle()
@Controller('users')
export class UsersController {}
```

`@SkipThrottle()` 装饰器不仅能跳过限流，还能在已跳过限流的类中，通过参数对特定路由重新启用限流。

```ts
@SkipThrottle()
@Controller('users')
export class UsersController {
  // 此路由将应用限流策略
  @SkipThrottle({ default: false })
  dontSkip() {
    return 'List users work with Rate limiting.'
  }

  // 此路由将跳过限流
  doSkip() {
    return 'List users work without Rate limiting.'
  }
}
```

此外，你还可以使用 `@Throttle()` 装饰器来覆盖全局配置的 `limit` 和 `ttl`，以实现更精细的安全策略。该装饰器可应用于类或方法级别。自 v5 版本起，该装饰器接收一个对象，其键是限流规则的名称 (若未命名，则为 `default`)，值是包含 `limit` 和 `ttl` 的新配置。示例如下：

```ts
// 覆盖默认的限流次数和持续时间
@Throttle({ default: { limit: 3, ttl: 60000 } })
@Get()
findAll() {
  return "List users works with custom rate limiting.";
}
```

## 代理服务器

如果你的应用部署在代理服务器之后，必须将 HTTP 适配器配置为信任代理，以便正确获取客户端 IP。你可以参考 [Express](http://expressjs.com/en/guide/behind-proxies.html) 和 [Fastify](https://www.fastify.io/docs/latest/Reference/Server/#trustproxy) 的官方文档来启用 `trust proxy` 设置。

以下示例演示了如何为 Express 适配器启用 `trust proxy`：

```ts filename='main.ts'
import { NestFactory } from '@nestjs/core'
import { AppModule } from './app.module'
import { NestExpressApplication } from '@nestjs/platform-express'

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule)
  app.set('trust proxy', 'loopback') // 信任来自 loopback 地址的请求
  await app.listen(3000)
}

bootstrap()
```

启用 `trust proxy` 后，`ThrottlerModule` 将能通过 `X-Forwarded-For` 请求头获取真实的客户端 IP。你还可以通过继承 `ThrottlerGuard` 并重写 `getTracker()` 方法，来完全自定义 IP 的追踪逻辑 (例如，从不同的请求头中提取)，而不依赖默认的 `req.ip`。以下示例展示了如何实现：

```ts filename='throttler-behind-proxy.guard.ts'
import { ThrottlerGuard } from '@nestjs/throttler'
import { Injectable } from '@nestjs/common'

@Injectable()
export class ThrottlerBehindProxyGuard extends ThrottlerGuard {
  protected async getTracker(req: Record<string, any>): Promise<string> {
    return req.ips.length ? req.ips[0] : req.ip // 可根据需求自定义 IP 提取逻辑
  }
}
```

<CalloutInfo>
  你可以在 Express 的[官方文档](https://expressjs.com/en/api.html#req.ips)和 Fastify
  的[官方文档](https://www.fastify.io/docs/latest/Reference/Request/)中查阅 `req` 请求对象的 API。
</CalloutInfo>

## WebSocket 通信

本模块同样支持 WebSocket 通信，但这需要对 `ThrottlerGuard` 进行扩展。你可以通过继承该守卫并重写 `handleRequest` 方法来实现，示例如下：

```ts
@Injectable()
export class WsThrottlerGuard extends ThrottlerGuard {
  async handleRequest(requestProps: ThrottlerRequest): Promise<boolean> {
    const { context, limit, ttl, throttler, blockDuration, getTracker, generateKey } = requestProps

    const client = context.switchToWs().getClient()
    const tracker = client._socket.remoteAddress
    const key = generateKey(context, tracker, throttler.name)
    const { totalHits, timeToExpire, isBlocked, timeToBlockExpire } =
      await this.storageService.increment(key, ttl, limit, blockDuration, throttler.name)

    const getThrottlerSuffix = (name: string) => (name === 'default' ? '' : `-${name}`)

    // 当请求总数超过限制时，抛出节流异常
    if (isBlocked) {
      await this.throwThrottlingException(context, {
        limit,
        ttl,
        key,
        tracker,
        totalHits,
        timeToExpire,
        isBlocked,
        timeToBlockExpire,
      })
    }

    // 允许请求通过
    return true
  }
}
```

<CalloutInfo>
  `context.switchToWs().getClient()` 返回的客户端对象会因你使用的 WebSocket 驱动而异。
  - **对于 `@nestjs/platform-ws`**：如示例所示，`client._socket.remoteAddress` 通常可以获取 IP 地址。
  - **对于 `socket.io`**：你可以尝试通过 `client.handshake.address` 获取 IP。

请注意，依赖 `_socket` 这类内部属性可能在不同版本间存在兼容性问题。

</CalloutInfo>

在使用 WebSocket 通信时，有几点需要注意：

- 此守卫不能通过 `APP_GUARD` 或 `app.useGlobalGuards()` 全局注册。
- 当请求被限制时，守卫会抛出 `ThrottlingException`，Nest 会发出一个 `exception` 事件。请确保你有一个监听此事件的异常过滤器。

## GraphQL 查询

`ThrottlerGuard` 同样可以保护 GraphQL 解析器 (Resolver)。只需继承该守卫，并重写 `getRequestResponse` 方法，从中提取原生的 `request` 和 `response` 对象即可。

```ts
@Injectable()
export class GqlThrottlerGuard extends ThrottlerGuard {
  getRequestResponse(context: ExecutionContext) {
    const gqlCtx = GqlExecutionContext.create(context)
    const ctx = gqlCtx.getContext()
    return { req: ctx.req, res: ctx.res }
  }
}
```

## 配置

以下选项可用于 `ThrottlerModule` 选项数组中的配置对象：

| 参数               | 描述                                                                                                                       |
| :----------------- | :------------------------------------------------------------------------------------------------------------------------- |
| `name`             | 用于内部追踪当前限流器集合的名称。如果未传递，则默认为 `'default'`                                                         |
| `ttl`              | 每个请求在存储中持续的毫秒数                                                                                               |
| `limit`            | 在 TTL 限制内允许的最大请求次数                                                                                            |
| `blockDuration`    | 请求被阻止的持续时间 (毫秒)                                                                                                |
| `ignoreUserAgents` | 一个包含需要忽略限流的用户代理 (User-Agent) 正则表达式的数组                                                               |
| `skipIf`           | 一个函数，接收 `ExecutionContext` 并返回 `boolean`，用于短路限流逻辑。类似于 `@SkipThrottle()`，但可基于请求自定义跳过条件 |

如果你需要设置存储 (storage)，或者希望以更全局的方式应用上述部分选项 (即应用于每个限流器集合)，可以通过 `throttlers` 选项键传递上述选项，并参考下表：

| 参数               | 描述                                                                                                                                                             |
| :----------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `storage`          | 自定义存储服务，用于记录限流信息。[详见此处](#存储方式)。                                                                                                        |
| `ignoreUserAgents` | 一个包含需要忽略限流的用户代理正则表达式的数组                                                                                                                   |
| `skipIf`           | 一个函数，接收 `ExecutionContext` 并返回 `boolean`，用于短路限流逻辑。类似于 `@SkipThrottle()`，但可基于请求自定义跳过条件                                       |
| `throttlers`       | 限流器集合的数组，定义方式见上表                                                                                                                                 |
| `errorMessage`     | 一个 `string` 或函数，接收 `ExecutionContext` 和 `ThrottlerLimitDetail`，返回 `string`，用于自定义限流错误消息，覆盖默认提示                                     |
| `getTracker`       | 一个函数，接收 `Request` 对象并返回 `string`，用于覆盖 `getTracker` 方法的默认逻辑                                                                               |
| `generateKey`      | 一个函数，接收 `ExecutionContext`、追踪字符串 `string` 以及限流器名称 `string`，返回 `string`，用于覆盖 `generateKey` 方法的默认逻辑，决定最终用于存储限流值的键 |

## 异步配置

有时你可能希望以异步方式获取限流配置，而不是同步进行。此时可以使用 `forRootAsync()` 方法，该方法支持依赖注入和 `async` 方法。

一种常见做法是使用工厂函数：

```ts
@Module({
  imports: [
    ThrottlerModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (config: ConfigService) => [
        {
          ttl: config.get('THROTTLE_TTL'),
          limit: config.get('THROTTLE_LIMIT'),
        },
      ],
    }),
  ],
})
export class AppModule {}
```

你也可以使用 `useClass` 语法：

```ts
@Module({
  imports: [
    ThrottlerModule.forRootAsync({
      imports: [ConfigModule],
      useClass: ThrottlerConfigService,
    }),
  ],
})
export class AppModule {}
```

只要 `ThrottlerConfigService` 实现了 `ThrottlerOptionsFactory` 接口，这种方式便同样可行。

## 存储方式

模块内置的存储器是一个内存缓存，它会追踪请求记录，直到记录的存活时间 (TTL) 结束。你可以提供自己的存储器来替换默认实现，只需让自定义的类实现 `ThrottlerStorage` 接口，并将其传递给模块的 `storage` 选项即可。

对于分布式应用场景，你可以使用社区提供的 [Redis 存储适配器](https://github.com/jmcdo29/nest-lab/tree/main/packages/throttler-storage-redis)，以实现统一的限流数据源。

<CalloutInfo>
  <div>`ThrottlerStorage` 接口可从 `@nestjs/throttler` 包中导入。</div>
</CalloutInfo>

## 时间辅助方法

为了提高可读性，`@nestjs/throttler` 导出了一些时间单位辅助函数，包括 `seconds`、`minutes`、`hours`、`days` 和 `weeks`。你可以直接使用它们来设置 `ttl` 或 `blockDuration`，例如 `seconds(5)`，函数会自动将其转换为毫秒。

## 迁移指南

对于大多数用户，只需将你的根配置选项包装在一个数组中即可完成迁移。

如果你正在使用自定义存储，应将原有的 `ttl` 和 `limit` 选项移入 `throttlers` 数组中。

所有的 `@SkipThrottle()` 装饰器现在都应接收一个 `{ [key: string]: boolean }` 形式的对象。其中的键是限流规则的名称 (如果未命名，则使用 `'default'`)。

同样，`@Throttle()` 装饰器现在也接收一个对象，其键为限流规则的名称 (默认为 `'default'`)，值为一个包含 `limit` 和 `ttl` 的新配置对象。

<CalloutInfo>
  请注意：v5 版本后，`ttl` 的单位已变更为**毫秒**。为了保持可读性，建议使用 `seconds()`
  等[时间辅助函数](#时间辅助方法)来设置时间，它会自动完成单位转换。
</CalloutInfo>

更多信息请参见[更新日志](https://github.com/nestjs/throttler/blob/master/CHANGELOG.md#500)

# 加密与哈希

**加密（Encryption）** 是指将信息（即“明文”）编码，使其转换为另一种无法直接读取的形式（即“密文”）。加密并不能防止数据被截获，但能确保即使数据落入未授权者手中，其内容也无法被轻易理解。这是一个可逆的过程：只有持有正确密钥的授权方，才能将密文解密，还原为原始信息。

**哈希（Hashing）** 是指将任意数据通过哈希函数，转换为一个固定长度的唯一标识。它是一个单向过程，意味着从生成的哈希值理论上无法反向推导出原始数据。

## 加密

Node.js 提供了内置的 [crypto 模块](https://nodejs.org/api/crypto.html)，它提供了丰富的功能，用于加密和解密字符串、Buffer、流等各类数据。为了避免引入不必要的抽象，Nest 鼓励开发者直接使用这个强大的原生模块。

下面以 AES（Advanced Encryption System，高级加密标准）的 `'aes-256-ctr'` 算法为例进行演示：

```ts
import { createCipheriv, randomBytes, scrypt } from 'crypto'
import { promisify } from 'util'

const iv = randomBytes(16)
const password = 'Password used to generate key'

// 密钥的长度取决于所选的加密算法。
// 例如，`aes256` 算法需要 32 字节的密钥。
const key = (await promisify(scrypt)(password, 'salt', 32)) as Buffer
const cipher = createCipheriv('aes-256-ctr', key, iv)

const textToEncrypt = 'Nest'
const encryptedText = Buffer.concat([cipher.update(textToEncrypt), cipher.final()])
```

现在，我们来解密 `encryptedText`：

```ts
import { createDecipheriv } from 'crypto'

const decipher = createDecipheriv('aes-256-ctr', key, iv)
const decryptedText = Buffer.concat([decipher.update(encryptedText), decipher.final()])
```

## 哈希

在需要进行哈希处理的场景中（例如安全地存储用户密码），我们强烈推荐使用 [bcrypt](https://www.npmjs.com/package/bcrypt) 或 [argon2](https://www.npmjs.com/package/argon2) 这类经过安全验证的专用库。与加密模块类似，Nest 并未对这些库进行封装，这使得你可以直接利用它们的原生功能，同时避免了不必要的抽象层。

下面以 `bcrypt` 为例，演示如何哈希密码。

首先，安装所需依赖：

```bash
$ npm i bcrypt
$ npm i -D @types/bcrypt
```

安装完成后，你可以使用 `hash` 函数来生成哈希值：

```ts
import * as bcrypt from 'bcrypt'

const saltOrRounds = 10
const password = 'random_password'
const hash = await bcrypt.hash(password, saltOrRounds)
```

如果你需要独立生成盐（salt），可以使用 `genSalt` 函数：

```ts
const salt = await bcrypt.genSalt()
```

要验证一个明文密码是否与给定的哈希值匹配，可以使用 `compare` 函数：

```ts
const isMatch = await bcrypt.compare(password, hash)
```

你可以在[这里](https://www.npmjs.com/package/bcrypt)了解更多关于 `bcrypt` 的可用函数和详细用法。

# 授权

**授权（Authorization）** 是指确定用户具备哪些操作权限的过程。例如，管理员用户可以创建、编辑和删除帖子，而普通用户通常只允许阅读帖子。

授权与身份验证（Authentication）是两个相互独立的概念。不过，授权通常依赖于身份验证机制来识别用户身份。

在实际开发中，授权可以通过多种方式和策略实现。具体采用哪种方案，需要根据项目的实际业务需求来决定。本章将介绍几种常见且适用于不同场景的授权实现方式。

## 基础 RBAC 实现

基于角色的访问控制（Role-based access control，RBAC）是一种围绕角色与权限定义、与策略无关的访问控制机制。本节将演示如何借助 Nest 的守卫实现一个非常基础的 RBAC 方案。

首先，创建一个 `Role` 枚举（enum），用于表示系统中的不同角色：

```ts filename='role.enum.ts'
export enum Role {
  User = 'user',
  Admin = 'admin',
}
```

<CalloutInfo>
  在更复杂的系统中，角色信息通常会存储在数据库中，或由外部身份验证服务提供。
</CalloutInfo>

有了这个枚举后，我们可以实现一个 `@Roles()` 装饰器，用于为特定资源指定所需角色。

```ts filename='roles.decorator.ts'
import { SetMetadata } from '@nestjs/common'
import { Role } from '../enums/role.enum'

export const ROLES_KEY = 'roles'
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles)
```

现在，我们已经有了自定义的 `@Roles()` 装饰器，可以将其应用于任意路由处理器（Route Handler）：

```ts filename='cats.controller.ts'
@Post()
@Roles(Role.Admin)
create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

接下来，需要实现一个 `RolesGuard` 类，用于比对当前用户拥有的角色与路由所需的角色。我们将借助框架自带、由 `@nestjs/core` 提供的 `Reflector` 辅助类来获取路由的角色（自定义元数据）。

```ts filename='roles.guard.ts'
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'
import { Reflector } from '@nestjs/core'

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ])
    if (!requiredRoles) {
      return true
    }
    const { user } = context.switchToHttp().getRequest()
    return requiredRoles.some((role) => user.roles?.includes(role))
  }
}
```

<CalloutInfo>
  关于如何在上下文中灵活使用
  `Reflector`，可参考“[反射与元数据](/fundamentals/execution-context#reflection-and-metadata)”章节。
</CalloutInfo>

<CalloutInfo type="warning">
  本示例之所以称为“基础”实现，是因为我们只在路由处理器级别检查角色。在实际项目中，某些接口或处理器可能涉及多个操作，每个操作都需要特定权限。此时，你需要在业务逻辑中自行实现角色校验机制，这会导致权限与具体操作的关联分散在各处，增加维护难度。
</CalloutInfo>

本示例假设 `request.user` 已包含用户实例及其拥有的角色（`roles` 属性）。在实际应用中，通常会在自定义的**身份验证守卫（Authentication Guard）** 中完成该关联。更多细节请参见[身份验证](/security/authentication)章节。

为了保证本示例正常工作，你的 `User` 类应类似如下：

```ts
class User {
  // ...其他属性
  roles: Role[]
}
```

最后，别忘了注册 `RolesGuard`，可以在控制器级别或全局注册。例如：

```ts
providers: [
  {
    provide: APP_GUARD,
    useClass: RolesGuard,
  },
],
```

当权限不足的用户请求接口时，Nest 会自动返回如下响应：

```ts
{
  "statusCode": 403,
  "message": "Forbidden resource",
  "error": "Forbidden"
}
```

<CalloutInfo>
  <div>
    如果你希望返回不同的错误响应，可以抛出自定义异常，而不是直接返回布尔值。
  </div>
</CalloutInfo>

## 基于声明的授权（Claims-based authorization）

当身份被创建后，可信任方可以为其分配一个或多个声明（Claim）。声明是一个名称-值对，用于描述主体（subject）拥有哪些权限，而不是主体的身份属性。

在 Nest 中实现基于声明的授权时，你可以参考上文 [RBAC](/security/authorization#basic-rbac-implementation) 部分的实现步骤。不同之处在于，这里不再检查特定角色，而是对比**权限**。每个用户会被分配一组权限，每个资源或端点则会定义访问所需的权限（例如，可以通过专用的 `@RequirePermissions()` 装饰器进行指定）。

```ts filename='cats.controller.ts'
@Post()
@RequirePermissions(Permission.CREATE_CAT)
create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

<CalloutInfo>
  在上述示例中，`Permission`（类似于我们在 RBAC 部分展示的 `Role`）是一个
  TypeScript 枚举类型，包含了系统中所有可用的权限。
</CalloutInfo>

## 集成 CASL

[CASL](https://casl.js.org/) 是一个同构的授权库，用于限制客户端可访问的资源。它支持渐进式集成，易于扩展，既能实现简单的声明式权限控制，也能满足复杂的基于主体和属性的授权需求。

首先，安装 `@casl/ability` 包：

```bash
$ npm i @casl/ability
```

<CalloutInfo>
  本文以 CASL 为例进行演示，你也可以根据项目需求或个人偏好选择其他库，如
  `accesscontrol` 或 `acl`。
</CalloutInfo>

安装完成后，为了便于演示 CASL 的用法，我们先定义两个实体类：`User` 和 `Article`。

```ts
class User {
  id: number
  isAdmin: boolean
}
```

`User` 类包含两个属性：`id`（用户唯一标识）和 `isAdmin`（是否为管理员）。

```ts
class Article {
  id: number
  isPublished: boolean
  authorId: number
}
```

`Article` 类有三个属性，分别是 `id`（文章唯一标识）、`isPublished`（文章是否已发布）和 `authorId`（作者用户的 ID）。

接下来，梳理本示例的权限需求：

- 管理员可以对所有实体进行增、查、改、删操作
- 普通用户对所有内容仅有只读权限
- 用户可以更新自己撰写的文章（`article.authorId === userId`）
- 已发布的文章不可被删除（`article.isPublished === true`）

基于上述需求，首先创建一个 `Action` 枚举，表示用户可对实体执行的所有操作：

```ts
export enum Action {
  Manage = 'manage',
  Create = 'create',
  Read = 'read',
  Update = 'update',
  Delete = 'delete',
}
```

<CalloutInfo type="warning">

`manage` 是 CASL 中的特殊关键字，表示“任意操作”。

</CalloutInfo>

为了更好地封装 CASL，我们需要创建 `CaslModule` 和 `CaslAbilityFactory`。

```bash
$ nest g module casl
$ nest g class casl/casl-ability.factory
```

接下来，在 `CaslAbilityFactory` 中定义 `createForUser()` 方法，为指定用户生成 Ability 对象：

```ts
type Subjects = InferSubjects<typeof Article | typeof User> | 'all'

export type AppAbility = MongoAbility<[Action, Subjects]>

@Injectable()
export class CaslAbilityFactory {
  createForUser(user: User) {
    const { can, cannot, build } = new AbilityBuilder(createMongoAbility)

    if (user.isAdmin) {
      can(Action.Manage, 'all') // 管理员拥有所有操作权限
    } else {
      can(Action.Read, 'all') // 普通用户仅有只读权限
    }

    can(Action.Update, Article, { authorId: user.id })
    cannot(Action.Delete, Article, { isPublished: true })

    return build({
      // 详细说明请参阅 https://casl.js.org/v6/en/guide/subject-type-detection#use-classes-as-subject-types
      detectSubjectType: (item) =>
        item.constructor as ExtractSubjectType<Subjects>,
    })
  }
}
```

<CalloutInfo>
  <div>`all` 是 CASL 中的特殊关键字，表示“任意主体”。</div>
</CalloutInfo>

<CalloutInfo>
  自 CASL v6 起，`MongoAbility` 成为默认能力类，取代了旧版的
  `Ability`，以更好地支持基于条件的权限（采用 MongoDB 风格语法）。虽然名称中带有
  Mongo，但它并不依赖 MongoDB，仅使用类似 Mongo 的语法进行条件判断。
</CalloutInfo>

<CalloutInfo>
  `MongoAbility`、`AbilityBuilder`、`AbilityClass` 和 `ExtractSubjectType` 均由
  `@casl/ability` 包导出。
</CalloutInfo>

<CalloutInfo>
  `detectSubjectType` 选项让 CASL 能够识别对象的主体类型。更多信息请参阅 [CASL
  文档](https://casl.js.org/v6/en/guide/subject-type-detection#use-classes-as-subject-types)。
</CalloutInfo>

在上述示例中，我们通过 `AbilityBuilder` 创建了 `MongoAbility` 实例。可以看到，`can` 和 `cannot` 方法参数相同但含义相反，`can` 用于授权，`cannot` 用于限制。两者最多可接收 4 个参数。详细用法请参考 [CASL 官方文档](https://casl.js.org/v6/en/guide/intro)。

最后，记得将 `CaslAbilityFactory` 添加到 `CaslModule` 的 `providers` 和 `exports` 数组中：

```ts
import { Module } from '@nestjs/common'
import { CaslAbilityFactory } from './casl-ability.factory'

@Module({
  providers: [CaslAbilityFactory],
  exports: [CaslAbilityFactory],
})
export class CaslModule {}
```

这样，在任何引入了 `CaslModule` 的类中，都可以通过标准构造函数注入方式使用 `CaslAbilityFactory`：

```ts
constructor(private caslAbilityFactory: CaslAbilityFactory) {}
```

然后在类中这样使用：

```ts
const ability = this.caslAbilityFactory.createForUser(user)
if (ability.can(Action.Read, 'all')) {
  // "user" 拥有所有内容的读取权限
}
```

<CalloutInfo>
  了解更多 `MongoAbility` 相关内容，请参阅 [CASL
  官方文档](https://casl.js.org/v6/en/guide/intro)。
</CalloutInfo>

举例来说，假设有一个非管理员用户。此时，该用户可以读取文章，但不能新建或删除文章：

```ts
const user = new User()
user.isAdmin = false

const ability = this.caslAbilityFactory.createForUser(user)
ability.can(Action.Read, Article) // true
ability.can(Action.Delete, Article) // false
ability.can(Action.Create, Article) // false
```

<CalloutInfo>
  虽然 `MongoAbility` 和 `AbilityBuilder` 都提供了 `can` 和 `cannot`
  方法，但他们的用途和参数略有不同。
</CalloutInfo>

同时，正如需求所述，用户应当可以更新自己撰写的文章：

```ts
const user = new User()
user.id = 1

const article = new Article()
article.authorId = user.id

const ability = this.caslAbilityFactory.createForUser(user)
ability.can(Action.Update, article) // true

article.authorId = 2
ability.can(Action.Update, article) // false
```

如上所示，`MongoAbility` 实例让我们可以直观地检查权限。`AbilityBuilder` 也允许以类似方式定义权限和条件。更多示例请参阅官方文档。

## 进阶：实现 `PoliciesGuard`（策略守卫）

本节将演示如何构建一个更复杂的守卫，用于检查用户是否满足可在方法级别配置的特定**授权策略（authorization policies）**。你还可以将其扩展为支持类级别的策略配置。这里以 CASL 包为例进行说明，但实际项目中并不一定要选择该库。此外，本例还会用到上一节中创建的 `CaslAbilityFactory` 提供者。

首先，让我们明确需求。目标是为每个路由处理器（Route Handler）提供一种机制，允许指定策略检查。我们将同时支持对象和函数两种方式，方便开发者根据实际需求选择（无论是简单检查还是偏好函数式风格）。

先来定义策略处理器的接口：

```ts
import { AppAbility } from '../casl/casl-ability.factory'

interface IPolicyHandler {
  handle(ability: AppAbility): boolean
}

type PolicyHandlerCallback = (ability: AppAbility) => boolean

export type PolicyHandler = IPolicyHandler | PolicyHandlerCallback
```

如上所示，策略处理器可以有两种定义方式：一种是对象（实现了 `IPolicyHandler` 接口的类实例），另一种是函数（符合 `PolicyHandlerCallback` 类型）。

有了这些定义后，我们可以创建一个 `@CheckPolicies()` 装饰器。该装饰器允许你为访问特定资源指定所需满足的策略。

```ts
export const CHECK_POLICIES_KEY = 'check_policy'
export const CheckPolicies = (...handlers: PolicyHandler[]) =>
  SetMetadata(CHECK_POLICIES_KEY, handlers)
```

接下来，创建一个 `PoliciesGuard`（策略守卫），用于提取并执行所有绑定到路由处理器的策略处理器。

```ts
@Injectable()
export class PoliciesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private caslAbilityFactory: CaslAbilityFactory
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const policyHandlers =
      this.reflector.get<PolicyHandler[]>(
        CHECK_POLICIES_KEY,
        context.getHandler()
      ) || []

    const { user } = context.switchToHttp().getRequest()
    const ability = this.caslAbilityFactory.createForUser(user)

    return policyHandlers.every((handler) =>
      this.execPolicyHandler(handler, ability)
    )
  }

  private execPolicyHandler(handler: PolicyHandler, ability: AppAbility) {
    if (typeof handler === 'function') {
      return handler(ability)
    }
    return handler.handle(ability)
  }
}
```

<CalloutInfo>
  在本例中，我们假设 `request.user`
  已包含用户实例。在你的应用中，通常会在自定义**身份验证守卫（authentication
  guard）**中完成这种关联。详见[身份验证](/security/authentication)章节获取更多信息。
</CalloutInfo>

我们来分解一下这个例子。`policyHandlers` 是通过 `@CheckPolicies()` 装饰器分配给方法的处理器数组。随后，我们使用 `CaslAbilityFactory#create` 方法构建 `Ability` 对象，用于验证用户是否有权限执行特定操作。该对象会被传递给策略处理器，无论是函数还是实现了 `IPolicyHandler` 接口的类实例（后者需实现返回布尔值的 `handle()` 方法）。最后，利用 `Array#every` 方法确保所有处理器都返回 `true`。

要测试这个守卫，只需将其绑定到任意路由处理器，并注册一个内联策略处理器（函数式写法），例如：

```ts
@Get()
@UseGuards(PoliciesGuard)
@CheckPolicies((ability: AppAbility) => ability.can(Action.Read, Article))
findAll() {
  return this.articlesService.findAll();
}
```

你也可以定义一个实现 `IPolicyHandler` 接口的类：

```ts
export class ReadArticlePolicyHandler implements IPolicyHandler {
  handle(ability: AppAbility) {
    return ability.can(Action.Read, Article)
  }
}
```

然后这样使用：

```ts
@Get()
@UseGuards(PoliciesGuard)
@CheckPolicies(new ReadArticlePolicyHandler())
findAll() {
  return this.articlesService.findAll();
}
```

<CalloutInfo type="warning">
  由于我们必须使用 `new` 关键字直接实例化策略处理器，`ReadArticlePolicyHandler` 类无法使用依赖注入。你可以通过 `ModuleRef#get` 方法解决这个问题（详见[此处](/fundamentals/module-ref)）。基本思路是允许通过 `@CheckPolicies()` 装饰器传递 `Type<IPolicyHandler>` 类型，而不是直接传递函数或实例。然后在守卫内部，使用类型引用获取实例：`moduleRef.get(YOUR_HANDLER_TYPE)`，或者甚至用 `ModuleRef#create` 方法动态实例化。
</CalloutInfo>

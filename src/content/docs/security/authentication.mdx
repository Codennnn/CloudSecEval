# 身份验证

身份验证（Authentication）是绝大多数应用程序中至关重要的一环。处理身份验证有多种方法和策略，具体选择哪一种，取决于项目的实际需求。本章将介绍几种能够适应不同需求的身份验证方案。

首先，我们来明确一下具体需求。在本章的示例中，客户端将使用用户名和密码进行身份验证。验证成功后，服务器会签发一个 JWT（JSON Web Token）。客户端在随后的请求中，可以将此 JWT 作为 [bearer token](https://tools.ietf.org/html/rfc6750) 附加在授权标头（Authorization Header）中，以表明自己的身份。最后，我们还会创建一个受保护的路由（protected route），该路由只允许携带有效 JWT 的请求访问。

我们将逐步实现这些功能：首先是用户身份验证，然后是签发 JWT，最后是创建一个检查 JWT 的受保护路由。

## 创建身份验证模块

首先，我们需要生成一个 `AuthModule`，并在其中创建 `AuthService` 和 `AuthController`。`AuthService` 将包含核心的身份验证逻辑，而 `AuthController` 则负责暴露与身份验证相关的 API 端点。

```bash
$ nest g module auth
$ nest g controller auth
$ nest g service auth
```

在实现 `AuthService` 的过程中，你会发现，如果把用户相关的逻辑提取并封装到 `UsersService` 中，代码结构会更清晰。因此，我们先来创建相应的模块和服务。

```bash
$ nest g module users
$ nest g service users
```

接下来，将自动生成的文件内容替换为如下代码。在本示例中，`UsersService` 仅维护一个硬编码的用户列表（存储在内存中），并提供一个按用户名查找用户的方法。在实际的应用程序中，你应该会使用数据库和持久化层来管理用户数据，例如通过 TypeORM、Sequelize 或 Mongoose 等库来实现。

```ts filename='users/users.service.ts'
import { Injectable } from '@nestjs/common'

// 这里应该是一个真正的用户实体类或接口
export type User = any

@Injectable()
export class UsersService {
  private readonly users = [
    {
      userId: 1,
      username: 'john',
      password: 'changeme',
    },
    {
      userId: 2,
      username: 'maria',
      password: 'guess',
    },
  ]

  async findOne(username: string): Promise<User | undefined> {
    return this.users.find((user) => user.username === username)
  }
}
```

在 `UsersModule` 中，我们还需要将 `UsersService` 添加到 `@Module` 装饰器的 `exports` 数组中。这样，该服务就能提供给其他模块使用（比如接下来要用到的 `AuthService`）。

```ts filename='users/users.module.ts'
import { Module } from '@nestjs/common'
import { UsersService } from './users.service'

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
```

## 实现登录接口

我们的 `AuthService`（认证服务）负责检索用户并验证密码。为此，我们实现了一个 `signIn()` 方法。如下代码所示，我们利用了 ES6 的展开运算符（spread operator），在返回用户对象前移除了 password 属性。这样做是为了避免在返回用户信息时暴露密码等敏感字段，这是实际开发中的常见做法。

```ts filename='auth/auth.service.ts'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { UsersService } from '../users/users.service'

@Injectable()
export class AuthService {
  constructor(private usersService: UsersService) {}

  async signIn(username: string, pass: string): Promise<any> {
    const user = await this.usersService.findOne(username)
    if (user?.password !== pass) {
      throw new UnauthorizedException()
    }
    const { password, ...result } = user
    // TODO: 实际项目中应生成 JWT 并返回
    // 此处仅为演示，直接返回用户对象
    return result
  }
}
```

<CalloutInfo type="warning">
  切勿在实际项目中以明文形式存储密码。你应当使用如
  [bcrypt](https://github.com/kelektiv/node.bcrypt.js#readme)
  这样的库，采用加盐的单向哈希算法。这样，系统只会存储哈希后的密码，并在校验时将传入密码进行哈希后比对，确保密码不会以明文形式存储或暴露。为了简化示例，这里直接使用了明文密码，这种做法仅用于演示，**请勿在真实项目中使用！**
</CalloutInfo>

接下来，我们需要更新 `AuthModule`（认证模块），导入 `UsersModule`（用户模块）。

```ts filename='auth/auth.module.ts'
import { Module } from '@nestjs/common'
import { AuthService } from './auth.service'
import { AuthController } from './auth.controller'
import { UsersModule } from '../users/users.module'

@Module({
  imports: [UsersModule],
  providers: [AuthService],
  controllers: [AuthController],
})
export class AuthModule {}
```

完成上述操作后，打开 `AuthController`（认证控制器），为其添加 `signIn()` 方法。该方法会被客户端调用，用于用户身份验证。它会从请求体中接收用户名和密码，认证通过后返回 JWT 令牌。

```ts filename='auth/auth.controller.ts'
import { Body, Controller, Post, HttpCode, HttpStatus } from '@nestjs/common'
import { AuthService } from './auth.service'

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.username, signInDto.password)
  }
}
```

<CalloutInfo>
在实际开发中，建议使用 DTO（Data Transfer Object，数据传输对象）类来定义请求体结构，而不是直接使用 `Record<string, any>` 类型。详细内容请参见[验证](/techniques/validation)章节。
</CalloutInfo>

## JWT 令牌

接下来，我们将进入认证系统的 JWT 部分。让我们先回顾并细化一下需求：

- 允许用户通过用户名和密码进行身份验证，并返回一个 JWT，用于后续访问受保护的 API 接口。我们已经基本实现了这个需求。要完成它，我们还需要编写签发 JWT 的代码。
- 创建基于 JWT 有效性（作为 Bearer Token 提供）的受保护 API 路由。

为支持 JWT 相关功能，我们需要额外安装一个包：

```bash
$ npm install --save @nestjs/jwt
```

<CalloutInfo>
  `@nestjs/jwt` 包（详见[这里](https://github.com/nestjs/jwt)是一个专门用于操作 JWT
  的工具库，提供了生成和验证 JWT 令牌的能力。
</CalloutInfo>

为了保持服务的良好模块化，我们将在 `authService` 中处理 JWT 的生成。请打开 `auth` 文件夹下的 `auth.service.ts` 文件，注入 `JwtService`，并按照如下方式更新 `signIn` 方法，实现 JWT 令牌的生成：

```ts filename='auth/auth.service.ts'
import { Injectable, UnauthorizedException } from '@nestjs/common'
import { UsersService } from '../users/users.service'
import { JwtService } from '@nestjs/jwt'

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async signIn(username: string, pass: string): Promise<{ access_token: string }> {
    const user = await this.usersService.findOne(username)
    if (user?.password !== pass) {
      throw new UnauthorizedException()
    }
    const payload = { sub: user.userId, username: user.username }
    return {
      access_token: await this.jwtService.signAsync(payload),
    }
  }
}
```

这里我们使用了 `@nestjs/jwt` 库，借助其 `signAsync()` 方法，根据 `user` 对象的部分属性生成 JWT，并以 `{ access_token }` 形式返回。需要注意的是，我们采用 `sub` 属性存储 `userId`，以符合 JWT 标准。

接下来，需要更新 `AuthModule`，引入新的依赖并配置 `JwtModule`。

首先，在 `auth` 文件夹下新建 `constants.ts` 文件，并添加如下内容：

```ts filename='auth/constants.ts'
export const jwtConstants = {
  secret:
    'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
}
```

该常量将在 JWT 签发和验证过程中用作密钥。

<CalloutInfo>
  **切勿公开暴露此密钥**。此处仅为演示代码结构而明文展示，实际生产环境中**必须通过机密管理、环境变量或配置服务等方式妥善保护此密钥**。
</CalloutInfo>

现在，打开 `auth` 文件夹下的 `auth.module.ts`，并更新为如下内容：

```ts filename='auth/auth.module.ts'
import { Module } from '@nestjs/common'
import { AuthService } from './auth.service'
import { UsersModule } from '../users/users.module'
import { JwtModule } from '@nestjs/jwt'
import { AuthController } from './auth.controller'
import { jwtConstants } from './constants'

@Module({
  imports: [
    UsersModule,
    JwtModule.register({
      global: true,
      secret: jwtConstants.secret,
      signOptions: { expiresIn: '60s' },
    }),
  ],
  providers: [AuthService],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}
```

<CalloutInfo>
  在这里，我们将 `JwtModule` 注册为全局模块，便于后续在其他地方直接使用，无需重复导入。
</CalloutInfo>

我们通过 `register()` 方法配置 `JwtModule`，传入相关配置对象。更多关于 Nest `JwtModule` 的信息可参考[官方文档](https://github.com/nestjs/jwt/blob/master/README.md)，配置项说明详见[这里](https://github.com/auth0/node-jsonwebtoken#usage)。

此时，你可以再次使用 cURL 测试接口。可用 `UsersService` 中硬编码的任意 `user` 对象进行验证。

```bash
$ # POST 到 /auth/login
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."}
$ # 注意：上方 JWT 已截断
```

## 实现身份验证守卫（Authentication Guard）

现在，我们来解决最后一个需求：要求每个请求都必须携带有效的 JWT，从而保护接口安全。为此，我们将创建一个 `AuthGuard`（身份验证守卫），用于实现路由保护。

```ts filename='auth/auth.guard.ts'
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from '@nestjs/common'
import { JwtService } from '@nestjs/jwt'
import { jwtConstants } from './constants'
import { Request } from 'express'

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private jwtService: JwtService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest()
    const token = this.extractTokenFromHeader(request)
    if (!token) {
      throw new UnauthorizedException()
    }
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      })
      // 💡 这里将 payload（载荷）赋值到 request 对象上
      // 这样在路由处理器中就能直接访问到用户信息
      request['user'] = payload
    } catch {
      throw new UnauthorizedException()
    }
    return true
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? []
    return type === 'Bearer' ? token : undefined
  }
}
```

接下来，我们可以实现受保护的路由，并注册 `AuthGuard`（身份验证守卫）来保护这些路由。

请打开 `auth.controller.ts` 文件，并按如下方式进行更新：

```ts filename='auth.controller.ts'
import {
  Body,
  Controller,
  Get,
  HttpCode,
  HttpStatus,
  Post,
  Request,
  UseGuards,
} from '@nestjs/common'
import { AuthGuard } from './auth.guard'
import { AuthService } from './auth.service'

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.username, signInDto.password)
  }

  @UseGuards(AuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user
  }
}
```

如上所示，我们将刚刚创建的 `AuthGuard` 应用到了 `GET /profile` 路由上。这样，该接口就实现了访问保护。

确保你的应用正在运行，并使用 `cURL` 工具测试这些接口。

```bash
$ # 尝试访问受保护的 GET /profile 接口
$ curl http://localhost:3000/auth/profile
{"statusCode":401,"message":"Unauthorized"}

$ # 进行登录，获取 access_token
$ curl -X POST http://localhost:3000/auth/login -d '{"username": "john", "password": "changeme"}' -H "Content-Type: application/json"
{"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."}

$ # 使用上一步返回的 access_token 作为 Bearer 令牌访问 /profile
$ curl http://localhost:3000/auth/profile -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2Vybm..."
{"sub": 1, "username": "john", "iat": ..., "exp": ...}
```

请注意，在 `AuthModule`（认证模块）中，我们将 JWT 的过期时间配置为 `60 秒`。实际上，这个过期时间较短，主要用于演示 JWT 的一个重要特性：如果你在认证后等待 60 秒再请求 `GET /auth/profile`，将会收到 `401 Unauthorized`（未授权）响应。这是因为 `@nestjs/jwt` 会自动校验 JWT 的过期时间，无需你在应用中手动处理。

至此，我们已经完成了 JWT 身份验证的实现。无论是 JavaScript 客户端（如 Angular、React、Vue），还是其他 JavaScript 应用，现在都可以安全地与我们的 API 服务器进行身份验证和通信。

## 全局启用身份验证

在实际开发中，如果你的绝大多数接口都需要进行保护，可以将身份验证守卫（AuthGuard）注册为[全局守卫](/guards#binding-guards)。这样，你无需在每个控制器上反复使用 `@UseGuards()` 装饰器，只需为需要公开访问的路由单独标记即可。

首先，你可以在任意模块（例如 `AuthModule`）中，将 `AuthGuard` 注册为全局守卫，具体方式如下：

```ts
providers: [
  {
    provide: APP_GUARD,
    useClass: AuthGuard,
  },
],
```

配置完成后，Nest 会自动将 `AuthGuard` 应用于所有接口，无需手动逐个绑定。

接下来，我们需要一种机制来声明哪些路由是公开的。为此，可以借助 `SetMetadata` 装饰器工厂函数，创建一个自定义装饰器：

```ts
import { SetMetadata } from '@nestjs/common'

export const IS_PUBLIC_KEY = 'isPublic'
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true)
```

在上述代码中，我们导出了两个常量：一个是元数据键 `IS_PUBLIC_KEY`，另一个是自定义装饰器 `Public`（你也可以根据实际需求命名为 `SkipAuth` 或 `AllowAnon` 等）。

有了自定义的 `@Public()` 装饰器后，可以将其用于需要公开访问的方法。例如：

```ts
@Public()
@Get()
findAll() {
  return [];
}
```

最后，我们还需要让 `AuthGuard` 能够识别 "isPublic" 元数据，并在检测到该标记时直接放行。可以通过 `Reflector` 类实现这一功能（详细用法见[此处](/guards#putting-it-all-together)）。

```ts
@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private reflector: Reflector
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ])
    if (isPublic) {
      // 💡 检测到公开路由，直接放行
      return true
    }

    const request = context.switchToHttp().getRequest()
    const token = this.extractTokenFromHeader(request)
    if (!token) {
      throw new UnauthorizedException()
    }
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      })
      // 💡 将 payload 赋值到 request 对象，便于后续访问用户信息
      request['user'] = payload
    } catch {
      throw new UnauthorizedException()
    }
    return true
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? []
    return type === 'Bearer' ? token : undefined
  }
}
```

## 集成 Passport

[Passport](https://github.com/jaredhanson/passport) 是目前社区中最受欢迎的 Node.js 身份验证库，已在众多生产环境中广泛应用。通过 `@nestjs/passport` 模块，你可以轻松地将 Passport 集成到 NestJS 应用中。

想了解如何在 NestJS 中集成 Passport？请参考本章的[详细说明](/recipes/passport)。

## 示例

本章[示例代码](https://github.com/nestjs/nest/tree/master/sample/19-auth-jwt)提供了完整的实现，欢迎查阅。

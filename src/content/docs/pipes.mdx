import pipeImage from '/public/assets/Pipe_1.png'

# 管道

管道（Pipe）是一个带有 `@Injectable()` 装饰器并实现 `PipeTransform` 接口的类。

<DocImage src={pipeImage} alt="管道结构图" />

管道主要有两大典型用途：

- **转换**：将输入数据转为期望格式（如将字符串转为整数）
- **校验**：验证输入数据，数据有效则原样传递，无效则抛出异常

在这两种场景下，管道都会对[控制器路由处理器](/controllers#route-parameters)正在处理的 `参数` 进行操作。Nest 会在方法调用前执行管道，管道接收即将传递给方法的参数并进行处理。所有转换或校验操作都在此阶段完成，随后路由处理器会收到（可能已被转换的）参数。

Nest 提供了多种内置管道可直接使用，也支持自定义管道。本章将介绍内置管道的用法及其绑定方式，并通过自定义管道示例，演示如何从零实现一个管道。

<CalloutInfo>
  管道在异常区域（exceptions
  zone）内运行。这意味着当管道抛出异常时，会被异常层（全局异常过滤器和当前上下文应用的[异常过滤器](/exception-filters)）捕获处理。因此，管道抛出异常时，控制器方法不会被执行。这为在系统边界校验外部输入数据提供了最佳实践。
</CalloutInfo>

## 内置管道

Nest 提供了以下内置管道：

- `ValidationPipe`
- `ParseIntPipe`
- `ParseFloatPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `ParseEnumPipe`
- `DefaultValuePipe`
- `ParseFilePipe`
- `ParseDatePipe`

这些管道均从 `@nestjs/common` 包中导出。

下面以 `ParseIntPipe` 为例，演示转换场景。该管道确保方法参数被转换为 JavaScript 整数（转换失败时会抛出异常）。本章后续还会展示一个简单的自定义 `ParseIntPipe` 实现。下述用法同样适用于其他内置转换管道（如 `ParseBoolPipe`、`ParseFloatPipe`、`ParseEnumPipe`、`ParseArrayPipe`、`ParseDatePipe`、`ParseUUIDPipe`，统称为 `Parse*` 管道）。

## 管道绑定方式

要使用管道，需要将管道类实例绑定到合适的上下文。以 `ParseIntPipe` 为例，我们希望将其应用于某个路由处理器方法，并确保在方法调用前执行。可以通过如下方式在方法参数级别绑定管道：

```ts
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

这样可以确保：要么 `findOne()` 方法接收到的参数是数字（如预期），要么在调用路由处理器前抛出异常。

例如，假设路由被如下方式调用：

```bash
GET localhost:3000/abc
```

Nest 会抛出如下异常：

```json
{
  "statusCode": 400,
  "message": "Validation failed (numeric string is expected)",
  "error": "Bad Request"
}
```

此异常会阻止 `findOne()` 方法体的执行。

在上述例子中，我们传递的是类（`ParseIntPipe`），而不是其实例。此时框架会自动实例化该管道，并支持依赖注入。与守卫、拦截器类似，也可以直接传递管道实例，适用于需要自定义内置管道行为（如传递选项）的场景：

```ts
@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}
```

其他转换管道（所有 `Parse*` 管道）的绑定方式类似。这些管道可用于校验路由参数、查询参数和请求体参数。

例如，绑定到查询参数：

```ts
@Get()
async findOne(@Query('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

下面是使用 `ParseUUIDPipe` 解析字符串参数并校验其是否为 UUID 的示例：

```ts
@Get(':uuid')
async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
  return this.catsService.findOne(uuid);
}
```

<CalloutInfo>
  使用 `ParseUUIDPipe()` 时，默认支持解析 3、4、5 版本的 UUID。如只需特定版本，可在管道选项中指定。
</CalloutInfo>

上述内容展示了 `Parse*` 系列内置管道的绑定方式。校验管道的绑定方式略有不同，详见下节。

<CalloutInfo>

更多校验管道用法详见[校验技术](/techniques/validation)。

</CalloutInfo>

## 自定义管道

如前所述，你可以自定义管道。虽然 Nest 已内置了强大的 `ParseIntPipe` 和 `ValidationPipe`，但我们还是从零实现一个简单版本，帮助理解自定义管道的构建方式。

下面实现一个最基础的 `ValidationPipe`，其初始版本仅接收输入值并原样返回，相当于恒等函数：

```ts filename='validation.pipe.ts'
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common'

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value
  }
}
```

<CalloutInfo>
  `PipeTransform<T, R>` 是所有管道必须实现的泛型接口。`T` 表示输入值类型，`R` 表示 `transform()` 方法的返回类型。
</CalloutInfo>

每个管道都必须实现 `transform()` 方法以满足 `PipeTransform` 接口契约。该方法有两个参数：

- `value`：当前处理的方法参数（在被路由处理器接收前）
- `metadata`：当前处理参数的元数据对象，包含以下属性：

```ts
export interface ArgumentMetadata {
  type: 'body' | 'query' | 'param' | 'custom'
  metatype?: Type<unknown>
  data?: string
}
```

这些属性描述了当前处理的参数。

| 属性       | 描述                                                                                                                              |
| ---------- | --------------------------------------------------------------------------------------------------------------------------------- |
| `type`     | 指示参数类型：请求体 `@Body()`、查询参数 `@Query()`、路由参数 `@Param()` 或自定义参数（详见[自定义装饰器](/custom-decorators)）。 |
| `metatype` | 参数的元类型，例如 `String`。注意：如果方法参数未声明类型，或使用原生 JavaScript，则该值为 `undefined`。                          |
| `data`     | 传递给装饰器的字符串，例如 `@Body('string')`。如果装饰器括号为空，则为 `undefined`。                                              |

<CalloutInfo type="warning">
  TypeScript 接口在转译后会被移除。因此，如果方法参数类型声明为接口而非类，`metatype` 的值会是
  `Object`。
</CalloutInfo>

## 基于模式的校验

让我们进一步提升校验管道的实用性。以 `CatsController` 的 `create()` 方法为例，通常我们希望在调用服务方法前，先确保请求体对象的有效性。

```ts
@Post()
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

此处，`createCatDto` 的类型为 `CreateCatDto`：

```ts filename='create-cat.dto.ts'
export class CreateCatDto {
  name: string
  age: number
  breed: string
}
```

我们希望所有对 create 方法的请求体都包含有效的对象，因此需要校验 `createCatDto` 的三个属性。虽然可以在路由处理器内部进行校验，但这样会违背**单一职责原则**（SRP）。

另一种方式是创建校验器类，并在每个方法开头调用，但这种做法容易被遗漏。

也可以考虑使用中间件进行校验，但中间件无法感知**执行上下文**（即当前被调用的处理器及其参数），因此难以实现通用校验。

这正是管道发挥作用的场景。下面我们来完善校验管道的实现。

## 基于对象模式的校验

实现对象校验有多种优雅方式，其中常见做法是基于模式（schema-based）的校验。这里以 [Zod](https://zod.dev/) 库为例，构建一个基于 Zod 的校验管道。

首先安装依赖：

```bash
$ npm install --save zod
```

下面的代码定义了一个接收 schema 的管道类，并通过 `schema.parse()` 校验参数。

如前所述，校验管道要么返回原始值，要么抛出异常。

下节将介绍如何通过 `@UsePipes()` 装饰器为控制器方法传递 schema，从而实现校验管道的复用。

```ts
import { PipeTransform, ArgumentMetadata, BadRequestException } from '@nestjs/common'
import { ZodSchema } from 'zod'

export class ZodValidationPipe implements PipeTransform {
  constructor(private schema: ZodSchema) {}

  transform(value: unknown, metadata: ArgumentMetadata) {
    try {
      const parsedValue = this.schema.parse(value)
      return parsedValue
    } catch (error) {
      throw new BadRequestException('Validation failed')
    }
  }
}
```

## 校验管道绑定

前文介绍了转换管道（如 `ParseIntPipe`）的绑定方式。

校验管道的绑定同样非常简单。

以 `ZodValidationPipe` 为例，使用步骤如下：

1. 创建 `ZodValidationPipe` 实例
2. 在管道构造函数中传入对应的 Zod schema
3. 将管道绑定到方法

Zod schema 示例：

```ts
import { z } from 'zod'

export const createCatSchema = z
  .object({
    name: z.string(),
    age: z.number(),
    breed: z.string(),
  })
  .required()

export type CreateCatDto = z.infer<typeof createCatSchema>
```

通过 `@UsePipes()` 装饰器绑定管道：

```ts filename='cats.controller.ts'
import { UsePipes } from '@nestjs/common'

@Post()
@UsePipes(new ZodValidationPipe(createCatSchema))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto)
}
```

<CalloutInfo type="warning">
  使用 `zod` 库时，需在 `tsconfig.json` 文件中启用 `strictNullChecks` 选项。
</CalloutInfo>

## 类装饰器校验器

<CalloutInfo type="warning">
  本节内容仅适用于 TypeScript，若你的项目为原生 JavaScript，则无法使用。
</CalloutInfo>

下面介绍另一种常用的校验方式。

Nest 与 [class-validator](https://github.com/typestack/class-validator) 库集成良好。该库允许你通过装饰器为类属性添加校验规则。装饰器驱动的校验方式非常强大，尤其结合 Nest 的管道机制时，可以访问参数的 `metatype`。在开始前，请先安装相关依赖：

```bash
$ npm i --save class-validator class-transformer
```

安装完成后，可以在 `CreateCatDto` 类上添加装饰器。这样做的显著优势是：`CreateCatDto` 既作为请求体的数据结构，也直接承担了校验职责，无需单独定义校验类。

```ts filename='create-cat.dto.ts'
import { IsString, IsInt } from 'class-validator'

export class CreateCatDto {
  @IsString()
  name: string

  @IsInt()
  age: number

  @IsString()
  breed: string
}
```

<CalloutInfo>
  更多 class-validator
  装饰器的用法请参见[官方文档](https://github.com/typestack/class-validator#usage)。
</CalloutInfo>

接下来，我们可以实现一个基于这些注解的 `ValidationPipe`：

```ts filename='validation.pipe.ts'
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common'
import { validate } from 'class-validator'
import { plainToInstance } from 'class-transformer'

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, { metatype }: ArgumentMetadata) {
    if (!metatype || !this.toValidate(metatype)) {
      return value
    }
    const object = plainToInstance(metatype, value)
    const errors = await validate(object)
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed')
    }
    return value
  }

  private toValidate(metatype: Function): boolean {
    const types: Function[] = [String, Boolean, Number, Array, Object]
    return !types.includes(metatype)
  }
}
```

<CalloutInfo>
  实际开发中无需手动实现通用的验证管道，Nest 已内置了功能更丰富的
  `ValidationPipe`。本示例仅用于演示自定义管道的实现机制。更多用法请参见[官方文档](/techniques/validation)。
</CalloutInfo>

<CalloutInfo type="warning">
  上述代码中用到的 [class-transformer](https://github.com/typestack/class-transformer) 与
  **class-validator** 由同一作者开发，两者配合使用效果最佳。
</CalloutInfo>

下面逐步解析上述代码：首先，`transform()` 方法被声明为 `async`，因为 class-validator 支持异步校验（部分校验规则会返回 Promise）。

其次，代码通过解构赋值直接获取 `ArgumentMetadata` 的 `metatype` 字段，这是一种简写方式。

`toValidate()` 方法用于判断参数类型是否为原生 JavaScript 类型（如 String、Boolean、Number、Array、Object），若是则跳过校验，因为这些类型无法添加校验装饰器。

随后，使用 class-transformer 的 `plainToInstance()` 方法将普通对象转换为带类型的实例，以便应用装饰器校验。原因在于，网络请求反序列化后的对象没有类型信息（如 Express 平台），而 class-validator 依赖 DTO 上的装饰器，因此必须进行类型转换。

作为验证管道，要么返回原值，要么抛出异常。

最后一步是绑定 `ValidationPipe`。管道可作用于参数级、方法级、控制器级或全局级。前文 Zod 校验管道的例子展示了方法级绑定。下面展示如何将管道实例绑定到路由处理器的 `@Body()` 装饰器，实现对请求体的校验：

```ts filename='cats.controller.ts'
@Post()
async create(
  @Body(new ValidationPipe()) createCatDto: CreateCatDto,
) {
  this.catsService.create(createCatDto)
}
```

参数级管道适用于只需校验某个特定参数的场景。

## 全局管道

由于 `ValidationPipe` 是通用管道，我们可以将其设置为全局管道，使其作用于整个应用的所有路由处理器。

```ts filename='main.ts'
async function bootstrap() {
  const app = await NestFactory.create(AppModule)
  app.useGlobalPipes(new ValidationPipe())
  await app.listen(process.env.PORT ?? 3000)
}

bootstrap()
```

<CalloutInfo type="warning">
  如果是[混合应用](/faq/hybrid-application)，`useGlobalPipes()`
  方法不会为网关（gateway）和微服务（microservices）设置管道。对于标准微服务应用，`useGlobalPipes()`
  会全局注册管道。
</CalloutInfo>

全局管道会应用于整个应用的所有控制器和路由处理器。

需要注意的是，通过如上例 `useGlobalPipes()` 这种在模块外部注册的全局管道，由于绑定发生在任何模块上下文之外，因此无法进行依赖注入。为了解决这一问题，可以通过如下方式在模块内部设置全局管道：

```ts filename='app.module.ts'
import { Module } from '@nestjs/common'
import { APP_PIPE } from '@nestjs/core'

@Module({
  providers: [
    {
      provide: APP_PIPE,
      useClass: ValidationPipe,
    },
  ],
})
export class AppModule {}
```

<CalloutInfo>
  使用此方法注册全局管道时，依赖注入将生效。无论在哪个模块中使用该方式，管道始终是全局的。建议在定义管道的模块中进行注册。此外，`useClass`
  并非唯一的自定义提供者注册方式。详细内容可参考[这里](/fundamentals/custom-providers)。
</CalloutInfo>

## 内置 ValidationPipe

需要再次强调，你无需自行实现通用的 `ValidationPipe`，因为 Nest 已经内置提供了 `ValidationPipe`。内置的 `ValidationPipe` 提供了比本章示例更多的选项，本章的实现仅用于演示自定义管道的基本机制。完整用法和丰富示例请参见[这里](/techniques/validation)。

## 转换用例

自定义管道不仅可用于校验，还可以转换输入数据为期望的格式。这是因为 `transform` 方法的返回值会完全覆盖参数的原始值。

这种能力在实际开发中非常有用。例如，客户端传递的数据可能需要转换（如将字符串转为整数），才能被路由处理器正确处理。此外，某些必需字段可能缺失，我们希望为其设置默认值。转换管道（Transformation pipe）可以在客户端请求与处理器之间插入处理逻辑，实现这些功能。

下面是一个简单的 `ParseIntPipe`，用于将字符串解析为整数。（需要注意，Nest 内置的 `ParseIntPipe` 功能更完善，这里仅作为自定义转换管道的示例。）

```ts filename='parse-int.pipe.ts'
import { PipeTransform, Injectable, ArgumentMetadata, BadRequestException } from '@nestjs/common'

@Injectable()
export class ParseIntPipe implements PipeTransform<string, number> {
  transform(value: string, metadata: ArgumentMetadata): number {
    const val = parseInt(value, 10)
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed')
    }
    return val
  }
}
```

可以如下将该管道绑定到指定参数：

```ts
@Get(':id')
async findOne(@Param('id', new ParseIntPipe()) id) {
  return this.catsService.findOne(id);
}
```

另一个常见的转换场景是：根据请求中的 id，从数据库中查找**已存在的用户**实体：

```ts
@Get(':id')
findOne(@Param('id', UserByIdPipe) userEntity: UserEntity) {
  return userEntity;
}
```

该管道的具体实现可作为练习。需要注意，和其他转换管道一样，它接收一个输入值（如 id），返回一个输出值（如 UserEntity 对象）。这样可以将样板代码从处理器中抽离到通用管道中，使代码更加声明式，并遵循 [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) 原则。

## 设置默认值

`Parse*` 管道要求参数值必须已定义。如果收到 `null` 或 `undefined`，会抛出异常。为了让接口能够处理缺失的查询参数值，我们需要在 `Parse*` 管道处理前注入一个默认值。`DefaultValuePipe` 就是为此设计的。只需在 `@Query()` 装饰器中，将 `DefaultValuePipe` 实例放在对应的 `Parse*` 管道之前即可：

```ts
@Get()
async findAll(
  @Query('activeOnly', new DefaultValuePipe(false), ParseBoolPipe) activeOnly: boolean,
  @Query('page', new DefaultValuePipe(0), ParseIntPipe) page: number,
) {
  return this.catsService.findAll({ activeOnly, page });
}
```

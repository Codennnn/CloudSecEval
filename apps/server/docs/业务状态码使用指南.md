# 业务状态码使用指南

## 概述

本项目采用了统一的业务状态码系统，用于规范 API 响应格式和错误处理。该系统提供了类型安全的状态码定义、统一的异常处理机制和标准化的响应格式。

## 设计原则

### 状态码分类

- **1xxxx (10000-19999)**: 成功状态码
- **2xxxx (20000-29999)**: 客户端错误状态码
- **3xxxx (30000-39999)**: 服务端错误状态码
- **4xxxx (40000-49999)**: 业务逻辑错误状态码

### 状态码结构

- 第一位数字表示大类
- 后四位数字表示具体错误类型
- 便于分类管理和快速识别

## 核心组件

### 1. 业务状态码定义

```typescript
// 成功状态码
export const SUCCESS_CODES = {
  SUCCESS: 10000,
  CREATED: 10001,
  LOGIN_SUCCESS: 10100,
  USER_CREATED: 10200,
  // ...
} as const;

// 客户端错误状态码
export const CLIENT_ERROR_CODES = {
  BAD_REQUEST: 20000,
  UNAUTHORIZED: 20100,
  USER_NOT_FOUND: 20301,
  EMAIL_ALREADY_EXISTS: 20401,
  // ...
} as const;
```

### 2. 业务异常类

```typescript
// 抛出业务异常
throw BusinessException.notFound(BUSINESS_CODES.USER_NOT_FOUND, "用户不存在");

// 快速创建常见异常
BusinessException.badRequest(code, message);
BusinessException.unauthorized(code, message);
BusinessException.forbidden(code, message);
BusinessException.notFound(code, message);
BusinessException.conflict(code, message);
BusinessException.internalServerError(code, message);
```

### 3. 响应工具函数

```typescript
// 成功响应
const response = success(
  { id: "123", name: "用户名" },
  "用户创建成功",
  BUSINESS_CODES.USER_CREATED
);

// 错误响应
const errorResponse = error(
  BUSINESS_CODES.VALIDATION_ERROR,
  "请求参数验证失败"
);
```

## 使用方法

### 在服务层使用

```typescript
@Injectable()
export class UserService {
  async createUser(userData: CreateUserDto) {
    // 检查邮箱是否已存在
    const existingUser = await this.findUserByEmail(userData.email);
    if (existingUser) {
      throw BusinessException.conflict(
        BUSINESS_CODES.EMAIL_ALREADY_EXISTS,
        "邮箱已存在"
      );
    }

    // 创建用户
    const user = await this.userRepository.create(userData);

    // 返回成功响应
    return success(user, "用户创建成功", BUSINESS_CODES.USER_CREATED);
  }

  async findUserById(id: string) {
    const user = await this.userRepository.findById(id);

    if (!user) {
      throw BusinessException.notFound(
        BUSINESS_CODES.USER_NOT_FOUND,
        "用户不存在"
      );
    }

    return success(user);
  }
}
```

### 在控制器中使用

```typescript
@Controller("users")
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  async createUser(@Body() createUserDto: CreateUserDto) {
    // 服务层已经返回标准响应格式，直接返回
    return await this.userService.createUser(createUserDto);
  }

  @Get(":id")
  async getUser(@Param("id") id: string) {
    // 异常处理交给全局异常过滤器
    return await this.userService.findUserById(id);
  }
}
```

## 响应格式

### 成功响应

```json
{
  "code": 10000,
  "message": "操作成功",
  "data": {
    "id": "123",
    "name": "用户名",
    "email": "user@example.com"
  }
}
```

### 分页响应

```json
{
  "code": 10000,
  "message": "操作成功",
  "data": [
    { "id": "1", "name": "用户1" },
    { "id": "2", "name": "用户2" }
  ],
  "pagination": {
    "total": 100,
    "page": 1,
    "pageSize": 10,
    "totalPages": 10
  }
}
```

### 错误响应

```json
{
  "code": 20301,
  "message": "用户不存在",
  "data": null
}
```

### 验证错误响应

```json
{
  "code": 20001,
  "message": "数据验证失败",
  "data": {
    "errors": [
      { "field": "email", "message": "邮箱格式不正确" },
      { "field": "password", "message": "密码长度至少6位" }
    ]
  }
}
```

## 常用状态码

### 成功状态码

| 状态码 | 常量                 | 说明         |
| ------ | -------------------- | ------------ |
| 10000  | SUCCESS              | 通用成功     |
| 10001  | CREATED              | 创建成功     |
| 10100  | LOGIN_SUCCESS        | 登录成功     |
| 10200  | USER_CREATED         | 用户创建成功 |
| 10300  | ORGANIZATION_CREATED | 组织创建成功 |

### 客户端错误状态码

| 状态码 | 常量                 | 说明             |
| ------ | -------------------- | ---------------- |
| 20000  | BAD_REQUEST          | 请求参数错误     |
| 20001  | VALIDATION_ERROR     | 数据验证失败     |
| 20100  | UNAUTHORIZED         | 未授权访问       |
| 20103  | INVALID_CREDENTIALS  | 用户名或密码错误 |
| 20200  | FORBIDDEN            | 权限不足         |
| 20301  | USER_NOT_FOUND       | 用户不存在       |
| 20401  | EMAIL_ALREADY_EXISTS | 邮箱已存在       |

### 服务端错误状态码

| 状态码 | 常量                   | 说明           |
| ------ | ---------------------- | -------------- |
| 30000  | INTERNAL_SERVER_ERROR  | 服务器内部错误 |
| 30100  | DATABASE_ERROR         | 数据库错误     |
| 30200  | EXTERNAL_SERVICE_ERROR | 外部服务错误   |

## 最佳实践

### 1. 状态码选择

- 选择最具体的状态码，避免使用过于通用的状态码
- 为业务特定的错误创建专门的状态码
- 保持状态码的语义一致性

### 2. 错误消息

- 提供清晰、用户友好的错误消息
- 避免暴露敏感的系统信息
- 支持国际化需求

### 3. 异常处理

- 在服务层抛出业务异常
- 让全局异常过滤器处理异常转换
- 避免在控制器中进行复杂的异常处理

### 4. 响应格式

- 使用工具函数创建标准响应
- 保持响应格式的一致性
- 合理使用分页响应

## 扩展指南

### 添加新的状态码

1. 在 `business-codes.ts` 中添加新的状态码定义
2. 在 `BUSINESS_CODE_MESSAGES` 中添加对应的消息
3. 更新类型定义以保持类型安全

```typescript
// 添加新的业务错误状态码
export const BUSINESS_ERROR_CODES = {
  // 现有状态码...
  NEW_BUSINESS_ERROR: 40400,
} as const;

// 添加对应的消息
export const BUSINESS_CODE_MESSAGES: Record<BusinessCode, string> = {
  // 现有消息...
  [BUSINESS_ERROR_CODES.NEW_BUSINESS_ERROR]: "新的业务错误",
};
```

### 自定义异常类型

```typescript
export class CustomBusinessException extends BusinessException {
  constructor(businessCode: BusinessCode, message?: string, extraData?: any) {
    super(businessCode, message, HttpStatus.BAD_REQUEST, extraData);
  }
}
```

## 迁移指南

### 从旧系统迁移

1. 替换现有的异常抛出方式
2. 更新响应格式
3. 修改异常过滤器
4. 更新前端对接代码

### 渐进式迁移

- 可以逐步替换现有的错误处理
- 保持向后兼容性
- 通过拦截器自动转换旧格式

这个业务状态码系统为您的 API 提供了统一、类型安全且易于维护的错误处理机制。通过合理使用这些工具，可以大大提高代码的可读性和维护性。
